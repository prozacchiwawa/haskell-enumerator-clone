\onecolumn
\section{Haddock API documentation}

This section just repeats literate documentation in Haddock syntax.

:d Data.Enumerator module header
-----------------------------------------------------------------------------
-- |
-- Module: Data.Enumerator
-- Copyright: 2010 John Millikin
-- License: MIT
--
-- Maintainer: jmillikin@gmail.com
-- Portability: portable
--
-- An implementation of Oleg Kiselyov&#x2019;s left-fold enumerators
--
-----------------------------------------------------------------------------
:

:d Data.Enumerator.List module header
-----------------------------------------------------------------------------
-- |
-- Module: Data.Enumerator.List
-- Copyright: 2010 John Millikin
-- License: MIT
--
-- Maintainer: jmillikin@gmail.com
-- Portability: portable
--
-- docs TODO
--
-----------------------------------------------------------------------------
:

:d Data.Enumerator.Binary module header
-----------------------------------------------------------------------------
-- |
-- Module: Data.Enumerator.Binary
-- Copyright: 2010 John Millikin
-- License: MIT
--
-- Maintainer: jmillikin@gmail.com
-- Portability: portable
--
-- Enumerator-based binary IO and processing
--
-----------------------------------------------------------------------------
:

:d Data.Enumerator.Text module header
-----------------------------------------------------------------------------
-- |
-- Module: Data.Enumerator.Text
-- Copyright: 2010 John Millikin
-- License: MIT
--
-- Maintainer: jmillikin@gmail.com
-- Portability: portable
--
-- Enumerator-based text IO
--
-----------------------------------------------------------------------------
:

:d Data.Enumerator.IO module header
-----------------------------------------------------------------------------
-- |
-- Module: Data.Enumerator.IO
-- Copyright: 2010 John Millikin
-- License: MIT
--
-- Maintainer: jmillikin@gmail.com
-- Portability: portable
--
-- Deprecated: use 'Data.Enumerator.IO' instead
--
-----------------------------------------------------------------------------
:

:d apidoc Data.Enumerator.($$)
-- | @($$) = (==\<\<)@
--
-- This might be easier to read when passing a chain of iteratees to an
-- enumerator.
:

:d apidoc Data.Enumerator.(<==<)
-- | @(\<==\<) = flip (>==>)@
:

:d apidoc Data.Enumerator.(==<<)
-- | @(==\<\<) = flip (\>\>==)@
:

:d apidoc Data.Enumerator.(>==>)
-- | @(>==>) e1 e2 s = e1 s >>== e2@
:

:d apidoc Data.Enumerator.(>>==)
-- | Equivalent to (>>=), but allows 'Iteratee's with different input types
-- to be composed.
:

:d apidoc Data.Enumerator.Continue
-- | The 'Iteratee' is capable of accepting more input. Note that more input
-- is not necessarily required; the 'Iteratee' might be able to generate a
-- value immediately if it receives 'EOF'.
:

:d apidoc Data.Enumerator.Enumeratee
-- | In cases where an enumerator acts as both a source and sink, the resulting
-- type is named an 'Enumeratee'. Enumeratees have two input types,
-- &#x201c;outer a&#x201d; (@aOut@) and &#x201c;inner a&#x201d; (@aIn@).
:

:d apidoc Data.Enumerator.Enumerator
-- | While 'Iteratee's consume data, enumerators generate it. Since
-- @'Iteratee'@ is an alias for @m ('Step' a m b)@, 'Enumerator's can
-- be considered step transformers of type
-- @'Step' a m b -> m ('Step' a m b)@.
--
-- 'Enumerator's typically read from an external source (parser, handle,
-- random generator, etc). They feed chunks into an 'Iteratee' until the
-- source runs out of data (triggering 'EOF') or the iteratee finishes
-- processing ('Yield's a value).
:

:d apidoc Data.Enumerator.Error
-- | The 'Iteratee' encountered an error which prevents it from proceeding
-- further.
:

:d apidoc Data.Enumerator.Iteratee
-- | The primary data type for this library, which consumes
-- input from a 'Stream' until it either generates a value or encounters
-- an error. Rather than requiring all input at once, an iteratee will
-- return 'Continue' when it is capable of processing more data.
--
-- In general, iteratees begin in the 'Continue' state. As each chunk is
-- passed to the continuation, the iteratee returns the next step:
-- 'Continue' for more data, 'Yield' when it's finished, or 'Error' to
-- abort processing.
:

:d apidoc Data.Enumerator.Stream
-- | A 'Stream' is a sequence of chunks generated by an 'Enumerator'.
--
-- @(Chunks [])@ is used to indicate that a stream is still active, but
-- currently has no available data. Iteratees should ignore empty chunks.
:

:d apidoc Data.Enumerator.Yield
-- | The 'Iteratee' cannot receive any more input, and has generated a
-- result. Included in this value is left-over input, which can be passed to
-- composed 'Iteratee's.
:

:d apidoc Data.Enumerator.break
:

:d apidoc Data.Enumerator.catchError
:

:d apidoc Data.Enumerator.checkDone
-- | @checkDone = checkDoneEx (Chunks [])@
--
-- Use this for enumeratees which do not have an input buffer.
:

:d apidoc Data.Enumerator.checkDoneEx
-- | A common pattern in 'Enumeratee' implementations is to check whether
-- the inner 'Iteratee' has finished, and if so, to return its output.
-- 'checkDone' passes its parameter a continuation if the 'Iteratee'
-- can still consume input, or yields otherwise.
:

:d apidoc Data.Enumerator.concatEnums
-- | Compose a list of 'Enumerator's using '(>>==)'
:

:d apidoc Data.Enumerator.concatMap
:

:d apidoc Data.Enumerator.concatMapM
:

:d apidoc Data.Enumerator.consume
:

:d apidoc Data.Enumerator.continue
:

:d apidoc Data.Enumerator.drop
:

:d apidoc Data.Enumerator.dropWhile
:

:d apidoc Data.Enumerator.enumEOF
:

:d apidoc Data.Enumerator.enumList
:

:d apidoc Data.Enumerator.filter
:

:d apidoc Data.Enumerator.filterM
:

:d apidoc Data.Enumerator.foldl
:

:d apidoc Data.Enumerator.foldl'
:

:d apidoc Data.Enumerator.foldM
:

:d apidoc Data.Enumerator.generateM
:

:d apidoc Data.Enumerator.head
:

:d apidoc Data.Enumerator.isEOF
:

:d apidoc Data.Enumerator.iterate
:

:d apidoc Data.Enumerator.iterateM
:

:d apidoc Data.Enumerator.joinI
-- | 'joinI' is used to &#x201C;flatten&#x201D; 'Enumeratee's into an
-- 'Iteratee'.
:

:d apidoc Data.Enumerator.last
:

:d apidoc Data.Enumerator.length
:

:d apidoc Data.Enumerator.liftFoldL
:

:d apidoc Data.Enumerator.liftFoldL'
:

:d apidoc Data.Enumerator.liftFoldM
:

:d apidoc Data.Enumerator.liftI
:

:d apidoc Data.Enumerator.liftTrans
-- | Lift an 'Iteratee' onto a monad transformer, re-wrapping the
-- 'Iteratee'&#x2019;s inner monadic values.
:

:d apidoc Data.Enumerator.map
:

:d apidoc Data.Enumerator.mapM
:

:d apidoc Data.Enumerator.peek
:

:d apidoc Data.Enumerator.printChunks
-- | Print chunks as they're received from the enumerator, optionally
-- printing empty chunks.
:

:d apidoc Data.Enumerator.repeat
:

:d apidoc Data.Enumerator.repeatM
:

:d apidoc Data.Enumerator.replicate
:

:d apidoc Data.Enumerator.replicateM
:

:d apidoc Data.Enumerator.returnI
:

:d apidoc Data.Enumerator.run
-- | Run an iteratee until it finishes, and return either the final value
-- (if it succeeded) or the error (if it failed).
:

:d apidoc Data.Enumerator.run_
:

:d apidoc Data.Enumerator.sequence
:

:d apidoc Data.Enumerator.span
:

:d apidoc Data.Enumerator.throwError
:

:d apidoc Data.Enumerator.yield
:

:d apidoc Data.Enumerator.Binary.consume
:

:d apidoc Data.Enumerator.Binary.drop
:

:d apidoc Data.Enumerator.Binary.dropWhile
:

:d apidoc Data.Enumerator.Binary.enumFile
-- | Opens a file path in binary mode, and passes the handle to 'enumHandle'.
-- The file will be closed when the 'Iteratee' finishes.
:

:d apidoc Data.Enumerator.Binary.enumHandle
-- | Read bytes (in chunks of the given buffer size) from the handle, and
-- stream them to an 'Iteratee'. If an exception occurs during file IO,
-- enumeration will stop and 'Error' will be returned. Exceptions from the
-- iteratee are not caught.
--
-- This enumerator blocks until at least one byte is available from the
-- handle, and might read less than the maximum buffer size in some
-- cases.
--
-- The handle should be opened with no encoding, and in 'IO.ReadMode' or
-- 'IO.ReadWriteMode'.
:

:d apidoc Data.Enumerator.Binary.head
:

:d apidoc Data.Enumerator.Binary.isolate
:

:d apidoc Data.Enumerator.Binary.iterHandle
-- | Read bytes from a stream and write them to a handle. If an exception
-- occurs during file IO, enumeration will stop and 'Error' will be
-- returned.
--
-- The handle should be opened with no encoding, and in 'IO.WriteMode' or
-- 'IO.ReadWriteMode'.
:

:d apidoc Data.Enumerator.Binary.require
:

:d apidoc Data.Enumerator.Binary.take
:

:d apidoc Data.Enumerator.Binary.takeWhile
:

:d apidoc Data.Enumerator.List.consume
:

:d apidoc Data.Enumerator.List.drop
:

:d apidoc Data.Enumerator.List.dropWhile
:

:d apidoc Data.Enumerator.List.head
:

:d apidoc Data.Enumerator.List.isolate
:

:d apidoc Data.Enumerator.List.require
:

:d apidoc Data.Enumerator.List.take
:

:d apidoc Data.Enumerator.List.takeWhile
:

:d apidoc Data.Enumerator.Text.Codec
:

:d apidoc Data.Enumerator.Text.consume
:

:d apidoc Data.Enumerator.Text.decode
:

:d apidoc Data.Enumerator.Text.drop
:

:d apidoc Data.Enumerator.Text.dropWhile
:

:d apidoc Data.Enumerator.Text.encode
:

:d apidoc Data.Enumerator.Text.enumFile
-- | Opens a file path in text mode, and passes the handle to 'enumHandle'.
-- The file will be closed when the 'Iteratee' finishes.
:

:d apidoc Data.Enumerator.Text.enumHandle
-- | Read lines of text from the handle, and stream them to an 'Iteratee'.
-- If an exception occurs during file IO, enumeration will stop and 'Error'
-- will be returned. Exceptions from the iteratee are not caught.
--
-- The handle should be opened with an appropriate text encoding, and
-- in 'IO.ReadMode' or 'IO.ReadWriteMode'.
:

:d apidoc Data.Enumerator.Text.head
:

:d apidoc Data.Enumerator.Text.isolate
:

:d apidoc Data.Enumerator.Text.iterHandle
-- | Read text from a stream and write it to a handle. If an exception
-- occurs during file IO, enumeration will stop and 'Error' will be
-- returned.
--
-- The handle should be opened with an appropriate text encoding, and
-- in 'IO.WriteMode' or 'IO.ReadWriteMode'.
:

:d apidoc Data.Enumerator.Text.require
:

:d apidoc Data.Enumerator.Text.take
:

:d apidoc Data.Enumerator.Text.takeWhile
:
