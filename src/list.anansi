\section{Lists}

:f Data/Enumerator/List.hs
|Data.Enumerator.List module header|
module Data.Enumerator.List (
	|Data.Enumerator.List exports|
	) where
import Data.Enumerator hiding (consume, head, peek)
import Control.Exception (ErrorCall(..))
import Prelude hiding (head, drop, dropWhile, take, takeWhile)
import qualified Data.List as L
:

:f Data/Enumerator/List.hs
|apidoc head|
head :: Monad m => Iteratee a m (Maybe a)
head = continue loop where
	loop (Chunks []) = head
	loop (Chunks (x:xs)) = yield (Just x) (Chunks xs)
	loop EOF = yield Nothing EOF
:

:f Data/Enumerator/List.hs
|apidoc drop|
drop :: Monad m => Integer -> Iteratee a m ()
drop 0 = return ()
drop n = continue (loop n) where
	len = L.genericLength
	loop n' (Chunks xs)
		| len xs < n' = drop (n' - len xs)
		| otherwise   = yield () (Chunks (L.genericDrop n' xs))
	loop _ EOF = yield () EOF
:

:f Data/Enumerator/List.hs
|apidoc dropWhile|
dropWhile :: Monad m => (a -> Bool) -> Iteratee a m ()
dropWhile p = continue loop where
	loop (Chunks xs) = case L.dropWhile p xs of
		[] -> continue loop
		xs' -> yield () (Chunks xs')
	loop EOF = yield () EOF
:

:f Data/Enumerator/List.hs
|apidoc take|
take :: Monad m => Integer -> Iteratee a m [a]
take 0 = return []
take n = continue (loop id n) where
	len = L.genericLength
	loop acc n' (Chunks xs)
		| len xs < n' = continue (loop (acc . (xs ++)) (n' - len xs))
		| otherwise   = let
			(xs', extra) = L.genericSplitAt n' xs
			in yield (acc xs') (Chunks extra)
	loop acc _ EOF = yield (acc []) EOF
:

:f Data/Enumerator/List.hs
|apidoc takeWhile|
takeWhile :: Monad m => (a -> Bool) -> Iteratee a m [a]
takeWhile p = continue (loop id) where
	loop acc (Chunks []) = continue (loop acc)
	loop acc (Chunks xs) = case Prelude.span p xs of
		(_, []) -> continue (loop (acc . (xs ++)))
		(xs', extra) -> yield (acc xs') (Chunks extra)
	loop acc EOF = yield (acc []) EOF
:

:d Data/Enumerator/List.hs (disabled)
peek :: Monad m => Integer -> Iteratee a m [a]
peek 0 = return []
peek n = continue (loop id n) where
	len = L.genericLength
	loop acc n' (Chunks xs)
		| len xs < n' = continue (loop (acc . (xs ++)) (n' - len xs))
		| otherwise   = let
			xs' = L.genericTake n' xs
			in yield (acc xs') (Chunks (acc xs))
	loop acc _ EOF = yield (acc []) EOF
:

:d Data/Enumerator/List.hs (disabled)
peekWhile :: Monad m => (a -> Bool) -> Iteratee a m [a]
peekWhile p = continue (loop id) where
	loop acc (Chunks []) = continue (loop acc)
	loop acc (Chunks xs) = case Prelude.span p xs of
		(_, []) -> continue (loop (acc . (xs ++)))
		(xs', _) -> yield (acc xs') (Chunks (acc xs))
	loop acc EOF = yield (acc []) EOF
:

:f Data/Enumerator/List.hs
|apidoc consume|
consume :: Monad m => Iteratee a m [a]
consume = Data.Enumerator.List.takeWhile (const True)
:

:f Data/Enumerator/List.hs
require :: Monad m => Integer -> Iteratee a m ()
require 0 = return ()
require n = continue (loop id n) where
	len = L.genericLength
	loop acc n' (Chunks xs)
		| len xs < n' = continue (loop (acc . (xs ++)) (n' - len xs))
		| otherwise   = yield () (Chunks (acc xs))
	loop _ _ EOF = throwError (ErrorCall "require: Unexpected EOF")
:

Note: {\tt isolate} has some odd behavior regarding extra input in the
inner iteratee. Depending on how large the chunks are, extra input might
be returned in the {\tt Step}, or dropped.

This doesn't matter if {\tt joinI} is used, but might if a user is poking
around inside the {\tt Step}. Eventually, enumeratees will be modified to
avoid exposing its internal iteratee state.

:f Data/Enumerator/List.hs
isolate :: Monad m => Integer -> Enumeratee a a m b
isolate 0 step = return step
isolate n (Continue k) = continue loop where
	len = L.genericLength
	
	loop (Chunks []) = continue loop
	loop (Chunks xs)
		| len xs <= n = k (Chunks xs) >>== isolate (n - len xs)
		| otherwise = let
			(s1, s2) = L.genericSplitAt n xs
			in k (Chunks s1) >>== (\step -> yield step (Chunks s2))
	loop EOF = k EOF >>== (\step -> yield step EOF)
isolate n step = drop n >> return step
:

:d Data.Enumerator.List exports
  head
, drop
, dropWhile
, take
, takeWhile
, consume
, require
, isolate
:

