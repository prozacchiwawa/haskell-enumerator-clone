\section{Lists}

:f Data/Enumerator/List.hs
|Data.Enumerator.List module header|
module Data.Enumerator.List (
	|Data.Enumerator.List exports|
	) where
import Data.Enumerator hiding ( consume, head, peek, drop, dropWhile
                              , concatMapM, replicateM, iterateM
                              , repeatM, generateM)
import Control.Exception (ErrorCall(..))
import Prelude hiding (head, drop, dropWhile, take, takeWhile, sequence)
import qualified Data.List as L
|Data.Enumerator.List imports|
:

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.head|
head :: Monad m => Iteratee a m (Maybe a)
head = continue loop where
	loop (Chunks []) = head
	loop (Chunks (x:xs)) = yield (Just x) (Chunks xs)
	loop EOF = yield Nothing EOF
:

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.drop|
drop :: Monad m => Integer -> Iteratee a m ()
drop n | n <= 0 = return ()
drop n = continue (loop n) where
	loop n' (Chunks xs) = iter where
		len = L.genericLength xs
		iter = if len < n'
			then drop (n' - len)
			else yield () (Chunks (L.genericDrop n' xs))
	loop _ EOF = yield () EOF
:

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.dropWhile|
dropWhile :: Monad m => (a -> Bool) -> Iteratee a m ()
dropWhile p = continue loop where
	loop (Chunks xs) = case L.dropWhile p xs of
		[] -> continue loop
		xs' -> yield () (Chunks xs')
	loop EOF = yield () EOF
:

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.take|
take :: Monad m => Integer -> Iteratee a m [a]
take n | n <= 0 = return []
take n = continue (loop id n) where
	len = L.genericLength
	loop acc n' (Chunks xs)
		| len xs < n' = continue (loop (acc . (xs ++)) (n' - len xs))
		| otherwise   = let
			(xs', extra) = L.genericSplitAt n' xs
			in yield (acc xs') (Chunks extra)
	loop acc _ EOF = yield (acc []) EOF
:

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.takeWhile|
takeWhile :: Monad m => (a -> Bool) -> Iteratee a m [a]
takeWhile p = continue (loop id) where
	loop acc (Chunks []) = continue (loop acc)
	loop acc (Chunks xs) = case Prelude.span p xs of
		(_, []) -> continue (loop (acc . (xs ++)))
		(xs', extra) -> yield (acc xs') (Chunks extra)
	loop acc EOF = yield (acc []) EOF
:

:# NOTE: peeking properly is currently impossible with the current design of
:# 'Stream'. Once it's updated to support EOF with "final data", peek can be
:# re-enabled
:#
:# :d Data/Enumerator/List.hs
:# |apidoc Data.Enumerator.List.peek|
:# peek :: Monad m => Integer -> Iteratee a m [a]
:# peek n | n <= 0 = return []
:# peek n = continue (loop id n) where
:# 	len = L.genericLength
:# 	loop acc n' (Chunks xs)
:# 		| len xs < n' = continue (loop (acc . (xs ++)) (n' - len xs))
:# 		| otherwise   = let
:# 			xs' = L.genericTake n' xs
:# 			in yield (acc xs') (Chunks (acc xs))
:# 	loop acc _ EOF = yield (acc []) EOF
:# :
:# 
:# :d Data/Enumerator/List.hs (disabled)
:# |apidoc Data.Enumerator.List.peekWhile|
:# peekWhile :: Monad m => (a -> Bool) -> Iteratee a m [a]
:# peekWhile p = continue (loop id) where
:# 	loop acc (Chunks []) = continue (loop acc)
:# 	loop acc (Chunks xs) = case Prelude.span p xs of
:# 		(_, []) -> continue (loop (acc . (xs ++)))
:# 		(xs', _) -> yield (acc xs') (Chunks (acc xs))
:# 	loop acc EOF = yield (acc []) EOF
:# :

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.consume|
consume :: Monad m => Iteratee a m [a]
consume = continue (loop id) where
	loop acc (Chunks []) = continue (loop acc)
	loop acc (Chunks xs) = continue (loop (acc . (xs ++)))
	loop acc EOF = yield (acc []) EOF
:

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.require|
require :: Monad m => Integer -> Iteratee a m ()
require n | n <= 0 = return ()
require n = continue (loop id n) where
	len = L.genericLength
	loop acc n' (Chunks xs)
		| len xs < n' = continue (loop (acc . (xs ++)) (n' - len xs))
		| otherwise   = yield () (Chunks (acc xs))
	loop _ _ EOF = throwError (ErrorCall "require: Unexpected EOF")
:

Note: {\tt isolate} has some odd behavior regarding extra input in the
inner iteratee. Depending on how large the chunks are, extra input might
be returned in the {\tt Step}, or dropped.

This doesn't matter if {\tt joinI} is used, but might if a user is poking
around inside the {\tt Step}. Eventually, enumeratees will be modified to
avoid exposing its internal iteratee state.

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.isolate|
isolate :: Monad m => Integer -> Enumeratee a a m b
isolate n step | n <= 0 = return step
isolate n (Continue k) = continue loop where
	len = L.genericLength
	
	loop (Chunks []) = continue loop
	loop (Chunks xs)
		| len xs <= n = k (Chunks xs) >>== isolate (n - len xs)
		| otherwise = let
			(s1, s2) = L.genericSplitAt n xs
			in k (Chunks s1) >>== (\step -> yield step (Chunks s2))
	loop EOF = k EOF >>== (\step -> yield step EOF)
isolate n step = drop n >> return step
:

:f Data/Enumerator/List.hs
splitWhen :: Monad m => (a -> Bool) -> Enumeratee a [a] m b
splitWhen p = sequence $ do
	as <- takeWhile (not . p)
	drop 1
	return as
:

Since iteratees are semantically a left-fold, there are many existing
folds that can be lifted to iteratees. The {\tt foldl}, {\tt foldl'}, and
{\tt foldM} functions work like their standard library namesakes, but
construct iteratees instead. These iteratees are not as complex as what can
be created using {\tt Yield} and {\tt Continue}, but cover many common cases.

Each fold consumes input from the stream until {\sc eof}, when it yields its
current accumulator.

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.fold|
fold :: Monad m => (b -> a -> b) -> b
       -> Iteratee a m b
fold step = continue . loop where
	f = L.foldl' step
	loop acc stream = case stream of
		Chunks [] -> continue (loop acc)
		Chunks xs -> continue (loop (f acc xs))
		EOF -> yield acc EOF
:

:d Data.Enumerator.List imports
import qualified Control.Monad as CM
import Control.Monad.Trans.Class (lift)
:

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.foldM|
foldM :: Monad m => (b -> a -> m b) -> b
      -> Iteratee a m b
foldM step = continue . loop where
	f = CM.foldM step
	
	loop acc stream = acc `seq` case stream of
		Chunks [] -> continue (loop acc)
		Chunks xs -> lift (f acc xs) >>= continue . loop
		EOF -> yield acc EOF
:

:d Data.Enumerator.List exports
  head
, drop
, dropWhile
, take
, takeWhile
, consume
, require
, isolate
, splitWhen
, fold
, Data.Enumerator.List.foldM
:

\subsection{Enumerators}

At their simplest, enumerators just check to see whether their received step
can accept any more input. If so, input is generated somehow, fed to the step,
and its result checked again. Most enumerators are defined using a
worker/wrapper pair, for efficiency and readability.

Here we define a number of enumerators based on functions from
{\tt Data.List}. Each generator has a monadic and non-monadic form, to
demonstrate how side effects might be ordered with respect to the iteratee's
processing.

{\tt iterate} and {\tt iterateM} apply a function repeatedly to the base
input, passing the results through as a stream.

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.iterate|
iterate :: Monad m => (a -> a) -> a -> Enumerator a m b
iterate f = loop where
	loop a (Continue k) = k (Chunks [a]) >>== loop (f a)
	loop _ step = returnI step
:

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.iterateM|
iterateM :: Monad m => (a -> m a) -> a
         -> Enumerator a m b
iterateM f base = loop (return base) where
	loop m_a (Continue k) = do
		a <- lift m_a
		k (Chunks [a]) >>== loop (f a)
	loop _ step = returnI step
:

{\tt repeat} and {\tt repeatM} create infinite streams, where each input
is a single value.

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.repeat|
repeat :: Monad m => a -> Enumerator a m b
repeat a = Data.Enumerator.List.iterate (const a) a
:

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.repeatM|
repeatM :: Monad m => m a -> Enumerator a m b
repeatM m_a step = do
	a <- lift m_a
	iterateM (const m_a) a step
:

{\tt replicate} and {\tt replicateM} create streams containing a given
quantity of the input value.

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.replicateM|
replicateM :: Monad m => Integer -> m a
           -> Enumerator a m b
replicateM maxCount getNext = loop maxCount where
	loop 0 step = returnI step
	loop n (Continue k) = do
		next <- lift getNext
		k (Chunks [next]) >>== loop (n - 1)
	loop _ step = returnI step
:

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.replicate|
replicate :: Monad m => Integer -> a
          -> Enumerator a m b
replicate maxCount a = replicateM maxCount (return a)
:

{\tt generateM} runs a monadic computation until it returns {\tt Nothing},
which signals the end of enumeration.

Note that when the enumerator is finished, it does not send {\tt EOF} to
the iteratee. Instead, it returns a continuation, so additional enumerators
may add their own input to the stream.

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.generateM|
generateM :: Monad m => m (Maybe a)
          -> Enumerator a m b
generateM getNext = loop where
	loop (Continue k) = do
		next <- lift getNext
		case next of
			Nothing -> continue k
			Just x -> k (Chunks [x]) >>== loop
	loop step = returnI step
:

:f Data/Enumerator/List.hs
unfold :: Monad m => (s -> Maybe (a, s)) -> s -> Enumerator a m b
unfold f = loop where
	loop s (Continue k) = case f s of
		Nothing -> continue k
		Just (a, s') -> k (Chunks [a]) >>== loop s'
	loop _ step = returnI step
:

:f Data/Enumerator/List.hs
unfoldM :: Monad m => (s -> m (Maybe (a, s))) -> s -> Enumerator a m b
unfoldM f = loop where
	loop s (Continue k) = do
		fs <- lift (f s)
		case fs of
			Nothing -> continue k
			Just (a, s') -> k (Chunks [a]) >>== loop s'
	loop _ step = returnI step
:

:d Data.Enumerator.List exports
-- ** Enumerators
, Data.Enumerator.List.iterate
, iterateM
, Data.Enumerator.List.repeat
, repeatM
, Data.Enumerator.List.replicate
, replicateM
, generateM
, unfold
, unfoldM
:

\subsection{Enumeratees}

Enumeratees are conceptually similar to a monadic {\tt concatMap}; each
outer input element is converted to a list of inner inputs, which are passed
to the inner iteratee. Error handling and performance considerations
make most real-life enumeratees more complex, but some don't need the extra
design.

The {\tt checkDone} and {\tt checkDoneEx} functions referenced here are
defined later, with other utilities.

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.concatMapM|
concatMapM :: Monad m => (ao -> m [ai])
           -> Enumeratee ao ai m b
concatMapM f = checkDone (continue . step) where
	step k EOF = yield (Continue k) EOF
	step k (Chunks xs) = loop k xs
	
	loop k [] = continue (step k)
	loop k (x:xs) = do
		fx <- lift (f x)
		k (Chunks fx) >>==
			checkDoneEx (Chunks xs) (\k' -> loop k' xs)
:

Once {\tt concatMapM} is defined, similar enumeratees can be easily created
via small wrappers.

:d excluded Prelude imports
concatMap,
:

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.concatMap|
concatMap :: Monad m => (ao -> [ai])
          -> Enumeratee ao ai m b
concatMap f = concatMapM (return . f)
:

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.map|
map :: Monad m => (ao -> ai)
    -> Enumeratee ao ai m b
map f = Data.Enumerator.List.concatMap (\x -> [f x])
:

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.filter|
filter :: Monad m => (a -> Bool)
       -> Enumeratee a a m b
filter p = Data.Enumerator.List.concatMap (\x -> [x | p x])
:

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.mapM|
mapM :: Monad m => (ao -> m ai)
     -> Enumeratee ao ai m b
mapM f = concatMapM (\x -> Prelude.mapM f [x])
:

:f Data/Enumerator/List.hs
|apidoc Data.Enumerator.List.filterM|
filterM :: Monad m => (a -> m Bool)
        -> Enumeratee a a m b
filterM p = concatMapM (\x -> CM.filterM p [x])
:

:d Data.Enumerator.List exports
-- ** Enumeratees
, Data.Enumerator.List.map
, Data.Enumerator.List.concatMap
, Data.Enumerator.List.filter
, Data.Enumerator.List.mapM
, concatMapM
, Data.Enumerator.List.filterM
:
