:# Copyright (C) 2010 John Millikin <jmillikin@gmail.com>
:#
:# See license.txt for details

\documentclass[12pt]{article}

\usepackage{color}
\usepackage{hyperref}
\usepackage{noweb}

:# Smaller margins
\usepackage[left=1.5cm,top=2cm,right=1.5cm,nohead,nofoot]{geometry}

:# Remove boxes from hyperlinks
\hypersetup{
    colorlinks,
    linkcolor=blue,
}

\makeindex

\begin{document}

\addcontentsline{toc}{section}{Contents}
\tableofcontents

\section{Introduction}

Enumerators are an abstraction discovered by Oleg Kiselyov, which provide a
performant, predictable, and safe alternative to lazy I/O.

:f Data/Enumerator.hs
|Data.Enumerator module header|
module Data.Enumerator (
	|Data.Enumerator exports|
	) where
|Data.Enumerator imports|
:

This module has a few functions which conflict with prelude names, so those
prelude values are imported as hidden.

:f Data/Enumerator.hs
import Prelude hiding (span)
import qualified Prelude as Prelude
:

Additionally, {\tt Integer}-enabled list functions are enabled to avoid ugly
{\tt Int} types in signatures.

:d Data.Enumerator imports
import Data.List (genericDrop, genericLength, genericSplitAt)
:


\section{Core types}

The fundamental types of this package are the {\tt Enumerator}, which
generates data streams, and the {\tt Iteratee}, which consumes them.

:d Data.Enumerator exports
  -- * Types
  Stream (..)
, Step (..)
, Iteratee (..)
, Enumerator
, Enumeratee
:

\subsection{Streams}

Not to be confused with types from the {\tt Stream} or
{\tt stream-fusion} packages, a {\tt Stream} is a sequence of chunks
generated by an enumerator. In contrast to Oleg's implementation,
this stream does not support error handling -- errors encountered
while generating a stream are reported in the {\tt Step} type instead.

{\tt (Chunks [])} is used to indicate that a stream is still active, but
currently has no available data. Iteratees should ignore empty chunks.

:f Data/Enumerator.hs
|apidoc Stream|
data Stream a
	= Chunks [a]
	| EOF
	deriving (Show, Eq)
:

\subsection{Iteratees}

The primary data type for this library is {\tt Iteratee}, which consumes
input from a {\tt Stream} until it either generates a value or encounters
an error. Rather than requiring all input at once, an iteratee will return
{\tt Continue} when it is capable of processing more data.

In general, iteratees begin in the {\tt Continue} state. As each chunk is
passed to the continuation, the iteratee may return the next step, which is
one of:

\begin{itemize}
\item {\tt Continue}: The iteratee is capable of accepting more input. Note
that more input is not required; the iteratee might be able to generate a
value immediately if the stream ends.

\item {\tt Yield}: The iteratee has received enough input to generate a
result. Included in this value is left-over input, which can be passed to
composed iteratees.

\item {\tt Error}: The iteratee encountered an error which prevents it from
proceeding further. The type of error will depend on the enumerator and/or
iteratee -- common choices are {\tt String} and {\tt SomeException}.
\end{itemize}

\filbreak

:f Data/Enumerator.hs
data Step e a m b
	|apidoc Step.Continue|
	= Continue (Stream a -> Iteratee e a m b)
	
	|apidoc Step.Yield|
	| Yield b (Stream a)
	
	|apidoc Step.Error|
	| Error e

|apidoc Iteratee|
newtype Iteratee e a m b = Iteratee
	{ runIteratee :: m (Step e a m b)
	}
:

\subsection{Enumerators}

While iteratees consume data, enumerators generate it. Since {\tt Iteratee} is
an alias for {\tt m (Step e a m b)}, enumerators can also be considered step
transformers of type {\tt Step e a m b -> m (Step e a m b)}.

Enumerators typically read from an external source (parser, handle, random
generator, etc). They feed chunks into an iteratee until the source runs out
of data (triggering {\tt EOF}) or the iteratee finishes processing (yields a
value).

In cases where an enumerator acts as both a source and sink, the resulting
type is named an {\tt Enumeratee}. Enumeratees have two input types,
``outer a'' ({\tt aOut}) and ``inner a'' ({\tt aIn}).

:f Data/Enumerator.hs
|apidoc Enumerator|
type Enumerator e a m b = Step e a m b -> Iteratee e a m b

|apidoc Enumeratee|
type Enumeratee e aOut aIn m b = Step e aIn m b -> Iteratee e aOut m (Step e aIn m b)
:

\subsection{Typeclass instances}

{\tt Stream} has a few instances, since it's effectively a wrapper around
{\tt []}.

:d Data.Enumerator imports
import Data.Monoid (Monoid, mempty, mappend, mconcat)
:

:f Data/Enumerator.hs
instance Monoid (Stream a) where
	mempty = Chunks mempty
	mappend (Chunks xs) (Chunks ys) = Chunks $ mappend xs ys
	mappend _ _ = EOF

instance Functor Stream where
	fmap f (Chunks xs) = Chunks $ fmap f xs
	fmap _ EOF = EOF

instance Monad Stream where
	return = Chunks . return
	Chunks xs >>= f = mconcat $ fmap f xs
	EOF >>= _ = EOF
:

However, the truly interesting instance is {\tt Monad} for {\tt Iteratee}.
Note that although the {\tt Yield} case to {\tt runIteratee (f x)} ignores
its surplus input, this is safe -- {\tt runIteratee (f x)} has not consumed
any input, so if it yields immediately there should not be surplus.

:f Data/Enumerator.hs
instance Monad m => Monad (Iteratee e a m) where
	return x = Iteratee . return $ Yield x $ Chunks []
	{-# INLINE return #-}
	
	m >>= f = Iteratee $ runIteratee m >>=
		\r1 -> case r1 of
			Continue k -> return $ Continue ((>>= f) . k)
			Error err -> return $ Error err
			Yield x (Chunks []) -> runIteratee $ f x
			Yield x chunk -> runIteratee (f x) >>=
				\r2 -> case r2 of
					Continue k -> runIteratee $ k chunk
					Error err -> return $ Error err
					Yield x' _ -> return $ Yield x' chunk
:

The {\tt Functor} interface is a bit awkward, but since {\tt m} will almost
always be a monad the extra requirement is OK.

:d Data.Enumerator imports
import qualified Control.Applicative as A
import Control.Monad (liftM, ap)
:

:f Data/Enumerator.hs
instance Monad m => Functor (Iteratee e a m) where
	fmap = liftM
	{-# INLINE fmap #-}

instance Monad m => A.Applicative (Iteratee e a m) where
	pure = return
	{-# INLINE pure #-}
	
	(<*>) = ap
	{-# INLINE (<*>) #-}
:

Most iteratees are used to wrap I/O operations, so it's sensible to define
a {\tt MonadIO} instance.

:d Data.Enumerator imports
import qualified Control.Monad.IO.Class as MIO
import qualified Control.Monad.Trans.Class as MT
:

:f Data/Enumerator.hs
instance MT.MonadTrans (Iteratee e a) where
	lift m = Iteratee $ m >>= runIteratee . return
	{-# INLINE lift #-}

instance MIO.MonadIO m => MIO.MonadIO (Iteratee e a m) where
	liftIO = MT.lift . MIO.liftIO
	{-# INLINE liftIO #-}
:

To simplify dealing with monad transformers, liftTrans allows lifting an
iteratee's internal monad.

:f Data/Enumerator.hs
|apidoc liftTrans|
liftTrans :: (Monad m, MT.MonadTrans t, Monad (t m)) =>
             Iteratee e a m b -> Iteratee e a (t m) b
liftTrans iter = Iteratee $ do
	step <- MT.lift $ runIteratee iter
	return $ case step of
		Yield x cs -> Yield x cs
		Error err -> Error err
		Continue k -> Continue (liftTrans . k)
:

\section{Primitives}

:d Data.Enumerator exports
  -- * Primitives
:

\subsection{Combinators}

These are common patterns which occur whenever iteratees are being defined.

\filbreak

:f Data/Enumerator.hs
-- | @returnI x = Iteratee (return x)@
returnI :: Monad m => Step e a m b -> Iteratee e a m b
returnI = Iteratee . return
{-# INLINE returnI #-}

-- | @yield x chunk = returnI (Yield x chunk)@
yield :: Monad m => b -> Stream a -> Iteratee e a m b
yield x chunk = returnI (Yield x chunk)
{-# INLINE yield #-}

-- | @continue k = returnI (Continue k)@
continue :: Monad m => (Stream a -> Iteratee e a m b) -> Iteratee e a m b
continue = returnI . Continue
{-# INLINE continue #-}

-- | @throwError err = returnI (Error err)@
throwError :: Monad m => e -> Iteratee e a m b
throwError = returnI . Error
{-# INLINE throwError #-}

-- | @liftI f = continue (returnI . f)@
liftI :: Monad m => (Stream a -> Step e a m b) -> Iteratee e a m b
liftI k = continue $ returnI . k
{-# INLINE liftI #-}
:

Catching errors is more difficult than throwing them, but defining this allows
{\tt Iteratee} to be an instance of various {\tt MonadError} classes.

:f Data/Enumerator.hs
catchError :: Monad m => Iteratee e a m b -> (e -> Iteratee e a m b) -> Iteratee e a m b
catchError iter h = Iteratee $ do
	step <- runIteratee iter
	case step of
		Error err -> runIteratee (h err)
		_ -> return step
:

These next two are equivalent to {\tt (>>=)} and {\tt (=<<)} respectively,
but allow iteratees with different input types to be composed. {\tt (==<<)}
is also aliased to {\tt ($$)}, to match Oleg's original code.

:f Data/Enumerator.hs
|apidoc (>>==)|
(>>==) :: Monad m =>
	Iteratee e a m b ->
	(Step e a m b -> Iteratee e a' m b') ->
	Iteratee e a' m b'
i >>== f = Iteratee $ runIteratee i >>= runIteratee . f
{-# INLINE (>>==) #-}

|apidoc (==<<)|
(==<<):: Monad m =>
	(Step e a m b -> Iteratee e a' m b') ->
	Iteratee e a m b ->
	Iteratee e a' m b'
(==<<) = flip (>>==)
{-# INLINE (==<<) #-}

|apidoc ($$)|
($$):: Monad m =>
	(Step e a m b -> Iteratee e a' m b') ->
	Iteratee e a m b ->
	Iteratee e a' m b'
($$) = (==<<)
{-# INLINE ($$) #-}
:

To make composing enumerators easier, equivalents to {\tt (>=>)} and
{\tt (<=<)} are defined.

:f Data/Enumerator.hs
|apidoc (>==>)|
(>==>) :: Monad m =>
	Enumerator e a m b ->
	(Step e a m b -> Iteratee e a' m b') ->
	Step e a m b ->
	Iteratee e a' m b'
(>==>) e1 e2 s = e1 s >>== e2
{-# INLINE (>==>) #-}

|apidoc (<==<)|
(<==<) :: Monad m =>
	(Step e a m b -> Iteratee e a' m b') ->
	Enumerator e a m b ->
	Step e a m b ->
	Iteratee e a' m b'
(<==<) = flip (>==>)
{-# INLINE (<==<) #-}
:

:d Data.Enumerator exports
  -- ** Combinators
  -- | These are common patterns which occur whenever iteratees are
  -- being defined.
, returnI
, yield
, continue
, throwError
, catchError
, liftI
, (>>==)
, (==<<)
, ($$)
, (>==>)
, (<==<)
:

\subsection{Iteratees}

:f Data/Enumerator.hs
|apidoc consume|
consume :: Monad m => Iteratee e a m [a]
consume = liftI $ step id where
	step acc chunk = case chunk of
		Chunks [] -> Continue $ returnI . step acc
		Chunks xs -> Continue $ returnI . (step $ acc . (xs ++))
		EOF -> Yield (acc []) EOF
:

:f Data/Enumerator.hs
|apidoc isEOF|
isEOF :: Monad m => Iteratee e a m Bool
isEOF = liftI $ \c -> case c of
	EOF -> Yield True c
	_   -> Yield False c
:

:f Data/Enumerator.hs
|apidoc liftFoldL|
liftFoldL :: Monad m => (b -> a -> b) -> b -> Iteratee e a m b
liftFoldL f = liftI . step where
	step acc chunk = case chunk of
		Chunks [] -> Continue $ returnI . step acc
		Chunks xs -> Continue $ returnI . step (Prelude.foldl f acc xs)
		EOF -> Yield acc EOF
:

:d Data.Enumerator imports
import qualified Data.List as DataList
:

:f Data/Enumerator.hs
|apidoc liftFoldL'|
liftFoldL' :: Monad m => (b -> a -> b) -> b -> Iteratee e a m b
liftFoldL' f = liftI . step where
	fold = DataList.foldl' f
	step acc chunk = case chunk of
		Chunks [] -> Continue $ returnI . step acc
		Chunks xs -> Continue $ returnI . (step $! fold acc xs)
		EOF -> Yield acc EOF
:

:d Data.Enumerator exports
  -- ** Iteratees
, consume
, isEOF
, liftTrans
, liftFoldL
, liftFoldL'
:

\subsection{Enumerators}

The most primitive enumerator;  simply sends {\tt EOF} to the iteratee. The
iteratee must either yield a value or throw an error -- continuing after EOF
will not terminate with any useful value.

:f Data/Enumerator.hs
|apidoc enumEOF|
enumEOF :: Monad m => Enumerator e a m b
enumEOF (Yield x _) = yield x EOF
enumEOF (Error err) = throwError err
enumEOF (Continue k) = k EOF >>== check where
	check (Continue _) = error "enumEOF: divergent iteratee"
	check s = enumEOF s
:

Another small, useful enumerator separates an input list into chunks, and
sends them to the iteratee. This is useful for testing iteratees in pure
code.

:f Data/Enumerator.hs
|apidoc enumList|
enumList :: Monad m => Integer -> [a] -> Enumerator e a m b
enumList n xs (Continue k) | not (null xs) = k chunk >>== loop where
	(s1, s2) = genericSplitAt n xs
	chunk = Chunks s1
	loop = enumList n s2
enumList _ _ step = returnI step
:

Sequencing a fixed set of enumerators is easy, but for more complex
cases, it's useful to have a small utility wrapper.

:f Data/Enumerator.hs
|apidoc concatEnums|
concatEnums :: Monad m => [Enumerator e a m b] -> Enumerator e a m b
concatEnums = foldl (>==>) returnI
{-# INLINE concatEnums #-}
:

:d Data.Enumerator exports
  -- ** Enumerators
, enumEOF
, enumList
, concatEnums
:

\subsection{Enumeratees}

{\tt joinI} is used to ``flatten'' enumeratees, to transform them into an
{\tt Iteratee}.

:f Data/Enumerator.hs
|apidoc joinI|
joinI :: Monad m => Iteratee e a m (Step e a' m b) -> Iteratee e a m b
joinI outer = outer >>= check where
	check (Continue k) = k EOF >>== \s -> case s of
		Continue _ -> error "joinI: divergent iteratee"
		_ -> check s
	check (Yield x _) = return x
	check (Error e) = throwError e
:

A common pattern in {\tt Enumeratee} implementations is to check whether
the inner {\tt Iteratee} has finished, and if so, to return its output.
{\tt checkDone} passes its parameter a continuation if the {\tt Iteratee}
can still consume input, or yields otherwise.

:f Data/Enumerator.hs
|apidoc checkDone|
checkDone :: Monad m =>
	((Stream a -> Iteratee e a m b) -> Iteratee e a' m (Step e a m b)) ->
	Enumeratee e a' a m b
checkDone _ (Yield x chunk) = return $ Yield x chunk
checkDone f (Continue k) = f k
checkDone _ (Error err) = throwError err
{-# INLINE checkDone #-}
:

{\tt map} and {\tt sequence} are two simple enumeratees, which behave like
their namesakes from the Prelude. {\tt map} applies its transform to each
element of the stream, and {\tt sequence} repeatedly runs its parameter to
transform the stream.

:f Data/Enumerator.hs
|apidoc map|
map :: Monad m => (ao -> ai) -> Enumeratee e ao ai m b
map f = loop where
	loop = checkDone $ continue . step
	step k EOF = yield (Continue k) EOF
	step k (Chunks []) = continue $ step k
	step k (Chunks xs) = k (Chunks (Prelude.map f xs)) >>== loop
:

:f Data/Enumerator.hs
|apidoc sequence|
sequence :: Monad m => Iteratee e ao m ai -> Enumeratee e ao ai m b
sequence i = loop where
	loop = checkDone check
	check k = isEOF >>= \f -> if f
		then yield (Continue k) EOF
		else step k
	step k = i >>= \v -> k (Chunks [v]) >>== loop
:

:d Data.Enumerator exports
  -- ** Enumeratees
, checkDone
, Data.Enumerator.map
, Data.Enumerator.sequence
, joinI
:

\section{Parser combinators}

Oleg's original {\tt IterateeM.hs} includes some basic iteratees for parsing,
so this section ports them to the new interface. However, in practice most
parsing will be performed with enumerator-based interfaces to Parsec or
Attoparsec.

:f Data/Enumerator.hs
|apidoc head|
head :: Monad m => Iteratee e a m (Maybe a)
head = liftI step where
	step (Chunks []) = Continue $ returnI . step
	step (Chunks (x:xs)) = Yield (Just x) (Chunks xs)
	step EOF = Yield Nothing EOF
:

:f Data/Enumerator.hs
|apidoc peek|
peek :: Monad m => Iteratee e a m (Maybe a)
peek = liftI step where
	step (Chunks []) = Continue $ returnI . step
	step chunk@(Chunks (x:_)) = Yield (Just x) chunk
	step chunk = Yield Nothing chunk
:

:f Data/Enumerator.hs
|apidoc last|
last :: Monad m => Iteratee e a m (Maybe a)
last = liftI $ step Nothing where
	step ret (Chunks xs) = let
		ret' = case xs of
			[] -> ret
			_  -> Just $ Prelude.last xs
		in Continue $ returnI . step ret'
	step ret EOF = Yield ret EOF
:

:f Data/Enumerator.hs
|apidoc length|
length :: Monad m => Iteratee e a m Integer
length = liftI $ step 0 where
	step n (Chunks xs) = Continue $ returnI . step (n + genericLength xs)
	step n EOF = Yield n EOF
:

:f Data/Enumerator.hs
|apidoc drop|
drop :: Monad m => Integer -> Iteratee e a m ()
drop 0 = return ()
drop n = liftI $ step n where
	step n' (Chunks xs)
		| len xs < n' = Continue $ returnI . step (n' - len xs)
		| otherwise   = Yield () $ Chunks $ genericDrop n' xs
	step _ EOF = Yield () EOF
	len = genericLength
:

:f Data/Enumerator.hs
|apidoc dropWhile|
dropWhile :: Monad m => (a -> Bool) -> Iteratee e a m ()
dropWhile p = liftI step where
	step (Chunks xs) = case Prelude.dropWhile p xs of
		[] -> Continue $ returnI . step
		xs' -> Yield () $ Chunks xs'
	step EOF = Yield () EOF
:

:f Data/Enumerator.hs
|apidoc span|
span :: Monad m => (a -> Bool) -> Iteratee e a m [a]
span f = liftI $ step [] where
	step acc (Chunks xs) = case Prelude.span f xs of
		(_, []) -> Continue $ returnI . step (acc ++ xs)
		(head', tail') -> Yield (acc ++ head') (Chunks tail')
	step acc EOF = Yield acc EOF

|apidoc break|
break :: Monad m => (a -> Bool) -> Iteratee e a m [a]
break p = span $ not . p
:

:d Data.Enumerator exports
  -- * Parser combinators
  |apidoc parser combinators|
, Data.Enumerator.head
, peek
, Data.Enumerator.last
, Data.Enumerator.length
, Data.Enumerator.drop
, Data.Enumerator.dropWhile
, span
, Data.Enumerator.break
:

\section{Utility}

To simplify running iteratees, {\tt run} sends {\tt EOF} and then examines
the result. It is not possible for the result to be {\tt Continue}, because
{\tt enumEOF} calls {\tt error} for divergent iteratees.

:f Data/Enumerator.hs
|apidoc run|
run :: Monad m => Iteratee e a m b -> m (Either e b)
run i = do
	mStep <- runIteratee $ enumEOF ==<< i
	case mStep of
		Error err -> return $ Left err
		Yield x _ -> return $ Right x
		Continue _ -> error "run: divergent iteratee"
:

:f Data/Enumerator.hs
|apidoc printChunks|
printChunks :: (MIO.MonadIO m, Show a) => Bool -> Iteratee e a m ()
printChunks printEmpty = continue step where
	step (Chunks []) | not printEmpty = continue step
	step (Chunks xs) = MIO.liftIO (print xs) >> continue step
	step EOF = MIO.liftIO (putStrLn "EOF") >> yield () EOF
:

:d Data.Enumerator exports
  -- * Utility functions
, run
, printChunks
:

\section{IO}

:f Data/Enumerator/IO.hs
|Data.Enumerator.IO module header|
module Data.Enumerator.IO
	( enumHandle
	, enumFile
	, iterFile
	, iterHandle
	) where
import Data.Enumerator
import Control.Monad.IO.Class (liftIO)
import qualified Control.Exception as E
import qualified Data.ByteString as B
import qualified System.IO as IO
:

:f Data/Enumerator/IO.hs
|apidoc enumHandle|
enumHandle :: Integer -- ^ Buffer size
           -> IO.Handle
           -> Enumerator E.SomeException B.ByteString IO b
enumHandle bufferSize h = Iteratee . loop where
	size' = fromInteger bufferSize
	loop (Continue k) = read' k
	loop step = return step
	read' k = do
		eitherB <- E.try $ B.hGet h size'
		case eitherB of
			Left err -> return $ Error err
			Right bytes | B.null bytes -> return $ Continue k
			Right bytes -> do
				step <- runIteratee (k (Chunks [bytes]))
				loop step
:

:f Data/Enumerator/IO.hs
|apidoc enumFile|
enumFile :: FilePath -> Enumerator E.SomeException B.ByteString IO b
enumFile path s = Iteratee $ do
	eitherH <- E.try $ IO.openBinaryFile path IO.ReadMode
	case eitherH of
		Left err -> return $ Error err
		Right h -> E.finally
			(runIteratee (enumHandle 4096 h s))
			(IO.hClose h)
:

:f Data/Enumerator/IO.hs
|apidoc iterHandle|
iterHandle :: IO.Handle -> Iteratee E.SomeException B.ByteString IO ()
iterHandle h = continue step where
	step EOF = yield () EOF
	step (Chunks bytes) = do
		eitherErr <- liftIO . E.try $ mapM_ (B.hPut h) bytes
		case eitherErr of
			Left err -> throwError err
			_ -> continue step
:

:f Data/Enumerator/IO.hs
|apidoc iterFile|
iterFile :: FilePath -> Iteratee E.SomeException B.ByteString IO ()
iterFile path = Iteratee $ do
	eitherH <- E.try $ IO.openBinaryFile path IO.WriteMode
	case eitherH of
		Left err -> return $ Error err
		Right h -> E.finally
			(runIteratee (iterHandle h))
			(IO.hClose h)
:

\section{Haddock API documentation}

This section just repeats literate documentation in Haddock syntax.

:d Data.Enumerator module header
-----------------------------------------------------------------------------
-- |
-- Module: Data.Enumerator
-- Copyright: 2010 John Millikin
-- License: MIT
--
-- Maintainer: jmillikin@gmail.com
-- Portability: portable
--
-- An implementation of Oleg Kiselyov&#x2019;s left-fold enumerators
--
-----------------------------------------------------------------------------
:

:d apidoc Stream
-- | Not to be confused with types from the @Stream@ or
-- @stream-fusion@ packages, a 'Stream' is a sequence of chunks
-- generated by an 'Enumerator'. In contrast to Oleg&#x2019;s implementation,
-- this stream does not support error handling -- errors encountered
-- while generating a stream are reported in the 'Step' type instead.
--
-- @(Chunks [])@ is used to indicate that a stream is still active, but
-- currently has no available data. Iteratees should ignore empty chunks.
:

:d apidoc Step.Continue
-- | The 'Iteratee' is capable of accepting more input. Note that more input
-- is not necessarily required; the 'Iteratee' might be able to generate a
-- value immediately if it receives 'EOF'.
:

:d apidoc Step.Yield
-- | The 'Iteratee' has received enough input to generate a result.
-- Included in this value is left-over input, which can be passed to
-- composed 'Iteratee's.
:

:d Data.Enumerator imports
import qualified Control.Exception as E
:

:d apidoc Step.Error
-- | The 'Iteratee' encountered an error which prevents it from proceeding
-- further. The type of error will depend on the 'Enumerator' and/or
-- 'Iteratee' -- common choices are 'String' and 'E.SomeException'.
:

:d apidoc Iteratee
-- | The primary data type for this library, which consumes
-- input from a 'Stream' until it either generates a value or encounters
-- an error. Rather than requiring all input at once, an iteratee will
-- return 'Continue' when it is capable of processing more data.
--
-- In general, iteratees begin in the 'Continue' state. As each chunk is
-- passed to the continuation, the iteratee returns the next step:
-- 'Continue' for more data, 'Yield' when it's finished, or 'Error' to
-- abort processing.
:

:d apidoc Enumerator
-- | While 'Iteratee's consume data, enumerators generate it. Since
-- @'Iteratee'@ is an alias for @m ('Step' e a m b)@, 'Enumerator's can
-- be considered step transformers of type
-- @'Step' e a m b -> m ('Step' e a m b)@.
--
-- 'Enumerator's typically read from an external source (parser, handle,
-- random generator, etc). They feed chunks into an 'Iteratee' until the
-- source runs out of data (triggering 'EOF') or the iteratee finishes
-- processing ('Yield's a value).
:

:d apidoc Enumeratee
-- | In cases where an enumerator acts as both a source and sink, the resulting
-- type is named an 'Enumeratee'. Enumeratees have two input types,
-- &#x201c;outer a&#x201d; (@aOut@) and &#x201c;inner a&#x201d; (@aIn@).
:

:d apidoc liftTrans
:

:d apidoc (>>==)
-- | Equivalent to (>>=), but allows 'Iteratee's with different input types
-- to be composed.
:

:d apidoc (==<<)
-- | @(==\<\<) = flip (\>\>==)@
:

:d apidoc ($$)
-- | @($$) = (==\<\<)@
--
-- This might be easier to read when passing a chain of iteratees to an
-- enumerator.
:

:d apidoc (>==>)
-- | @(>==>) e1 e2 s = e1 s >>== e2@
:

:d apidoc (<==<)
-- | @(\<==\<) = flip (>==>)@
:

:d apidoc consume
-- | Consume all input until 'EOF', then return consumed input as a list.
:

:d apidoc isEOF
-- | Return 'True' if the next 'Stream' is 'EOF'.
:

:d apidoc liftFoldL
-- | Lifts a pure left fold into an iteratee.
:

:d apidoc liftFoldL'
-- | As 'liftFoldL', but strict in its accumulator.
:

:d apidoc enumEOF
-- | The most primitive enumerator; simply sends 'EOF'. The iteratee must
-- either yield a value or throw an error continuing receiving 'EOF' will
-- not terminate with any useful value.
:

:d apidoc enumList
-- | Another small, useful enumerator separates an input list into chunks,
-- and sends them to the iteratee. This is useful for testing iteratees in pure
-- code.
:

:d apidoc concatEnums
-- | Compose a list of 'Enumerator's using '(>>==)'
:

:d apidoc joinI
-- | 'joinI' is used to &#x201C;flatten&#x201D; 'Enumeratee's into an
-- 'Iteratee'.
:

:d apidoc checkDone
-- | A common pattern in 'Enumeratee' implementations is to check whether
-- the inner 'Iteratee' has finished, and if so, to return its output.
-- 'checkDone' passes its parameter a continuation if the 'Iteratee'
-- can still consume input, or yields otherwise.
:

API docs for these are still TODO

:d apidoc map
:

:d apidoc sequence
:

:d apidoc head
:

:d apidoc peek
:

:d apidoc last
:

:d apidoc length
:

:d apidoc drop
:

:d apidoc dropWhile
:

:d apidoc span
:

:d apidoc break
-- | @break p = 'span' (not . p)@
:

:d apidoc parser combinators
-- | Oleg&#x2019;s original @IterateeM.hs@ includes some basic iteratees
-- for parsing, so this section ports them to the new interface. However,
-- in practice most parsing will be performed with enumerator-based
-- interfaces to existing parser libraries (such as Parsec or Attoparsec).
:

:d apidoc run
-- | Run an iteratee until it finishes, and return either the final value
-- (if it succeeded) or the error (if it failed).
:

:d apidoc printChunks
-- | Print chunks as they're received from the enumerator, optionally
-- printing empty chunks.
:

:d Data.Enumerator.IO module header
-----------------------------------------------------------------------------
-- |
-- Module: Data.Enumerator.IO
-- Copyright: 2010 John Millikin
-- License: MIT
--
-- Maintainer: jmillikin@gmail.com
-- Portability: portable
--
-- Enumerator-based IO
--
-----------------------------------------------------------------------------
:

:d apidoc enumHandle
-- | Read bytes (in chunks of the given buffer size) from the handle, and
-- stream them to an 'Iteratee'. If an exception occurs during file IO,
-- enumeration will stop and 'Error' will be returned. Exceptions from the
-- iteratee are not caught.
:

:d apidoc iterHandle
-- | Read bytes from a stream and write them to a handle. If an exception
-- occurs during file IO, enumeration will stop and 'Error' will be
-- returned.
:

:d apidoc enumFile
-- | Opens a file path in binary mode, and passes the handle to 'enumHandle'.
-- The file will be closed when the 'Iteratee' finishes.
:

:d apidoc iterFile
-- | Opens a file path in binary mode, and passes the handle to 'iterHandle'.
-- The file will be closed when the 'Iteratee' finishes.
:

\end{document}
