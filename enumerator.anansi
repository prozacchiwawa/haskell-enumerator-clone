:# Copyright (C) 2010 John Millikin <jmillikin@gmail.com>
:#
:# See license.txt for details

\documentclass[12pt]{article}

\usepackage{color}
\usepackage{hyperref}
\usepackage{noweb}

:# Smaller margins
\usepackage[left=1.5cm,top=2cm,right=1.5cm,nohead,nofoot]{geometry}

:# Remove boxes from hyperlinks
\hypersetup{
    colorlinks,
    linkcolor=blue,
}

\makeindex

\begin{document}

\addcontentsline{toc}{section}{Contents}
\tableofcontents

\section{Introduction}

Enumerators are an abstraction discovered by Oleg Kiselyov, which provide a
performant, predictable, and safe alternative to lazy I/O.

:f Data/Enumerator.hs
|Data.Enumerator module header|
module Data.Enumerator (
	|Data.Enumerator exports|
	) where
|Data.Enumerator imports|
:

This module has a few functions which conflict with prelude names, so those
prelude values are imported as hidden.

:f Data/Enumerator.hs
import Prelude hiding (span)
import qualified Prelude as Prelude
:

Additionally, {\tt Integer}-enabled list functions are enabled to avoid ugly
{\tt Int} types in signatures.

:d Data.Enumerator imports
import Data.List (genericDrop, genericLength, genericSplitAt)
:


\section{Core types}

The fundamental types of this package are the {\tt Enumerator}, which
generates data streams, and the {\tt Iteratee}, which consumes them.

:d Data.Enumerator exports
  -- * Types
  Stream (..)
, Step (..)
, Iteratee (..)
, Enumerator
, Enumeratee
:

\subsection{Streams}

Not to be confused with types from the {\tt Stream} or
{\tt stream-fusion} packages, a {\tt Stream} is a sequence of chunks
generated by an enumerator. In contrast to Oleg's implementation,
this stream does not support error handling -- errors encountered
while generating a stream are reported in the {\tt Step} type instead.

{\tt (Chunks [])} is used to indicate that a stream is still active, but
currently has no available data. Iteratees should ignore empty chunks.

:f Data/Enumerator.hs
|apidoc Stream|
data Stream a
	= Chunks [a]
	| EOF
	deriving (Show, Eq)
:

\subsection{Iteratees}

The primary data type for this library is {\tt Iteratee}, which consumes
input from a {\tt Stream} until it either generates a value or encounters
an error. Rather than requiring all input at once, an iteratee will return
{\tt Continue} when it is capable of processing more data.

In general, iteratees begin in the {\tt Continue} state. As each chunk is
passed to the continuation, the iteratee may return the next step, which is
one of:

\begin{itemize}
\item {\tt Continue}: The iteratee is capable of accepting more input. Note
that more input is not required; the iteratee might be able to generate a
value immediately if the stream ends.

\item {\tt Yield}: The iteratee has received enough input to generate a
result. Included in this value is left-over input, which can be passed to
composed iteratees.

\item {\tt Error}: The iteratee encountered an error which prevents it from
proceeding further.
\end{itemize}

\filbreak

:d Data.Enumerator imports
import qualified Control.Exception as E
:

:f Data/Enumerator.hs
data Step a m b
	|apidoc Step.Continue|
	= Continue (Stream a -> Iteratee a m b)
	
	|apidoc Step.Yield|
	| Yield b (Stream a)
	
	|apidoc Step.Error|
	| Error E.SomeException

|apidoc Iteratee|
newtype Iteratee a m b = Iteratee
	{ runIteratee :: m (Step a m b)
	}
:

\subsection{Enumerators}

While iteratees consume data, enumerators generate it. Since {\tt Iteratee} is
an alias for {\tt m (Step a m b)}, enumerators can also be considered step
transformers of type {\tt Step a m b -> m (Step a m b)}.

Enumerators typically read from an external source (parser, handle, random
generator, etc). They feed chunks into an iteratee until the source runs out
of data (triggering {\tt EOF}) or the iteratee finishes processing (yields a
value).

In cases where an enumerator acts as both a source and sink, the resulting
type is named an {\tt Enumeratee}. Enumeratees have two input types,
``outer a'' ({\tt aOut}) and ``inner a'' ({\tt aIn}).

:f Data/Enumerator.hs
|apidoc Enumerator|
type Enumerator a m b = Step a m b -> Iteratee a m b

|apidoc Enumeratee|
type Enumeratee aOut aIn m b = Step aIn m b -> Iteratee aOut m (Step aIn m b)
:

\subsection{Typeclass instances}

{\tt Stream} has a few instances, since it's effectively a wrapper around
{\tt []}.

:d Data.Enumerator imports
import Data.Monoid (Monoid, mempty, mappend, mconcat)
:

:f Data/Enumerator.hs
instance Monoid (Stream a) where
	mempty = Chunks mempty
	mappend (Chunks xs) (Chunks ys) = Chunks $ mappend xs ys
	mappend _ _ = EOF

instance Functor Stream where
	fmap f (Chunks xs) = Chunks $ fmap f xs
	fmap _ EOF = EOF

instance Monad Stream where
	return = Chunks . return
	Chunks xs >>= f = mconcat $ fmap f xs
	EOF >>= _ = EOF
:

However, the truly interesting instance is {\tt Monad} for {\tt Iteratee}.
Note that although the {\tt Yield} case to {\tt runIteratee (f x)} ignores
its surplus input, this is safe -- {\tt runIteratee (f x)} has not consumed
any input, so if it yields immediately there should not be surplus.

:f Data/Enumerator.hs
instance Monad m => Monad (Iteratee a m) where
	return x = Iteratee . return $ Yield x $ Chunks []
	{-# INLINE return #-}
	
	m >>= f = Iteratee $ runIteratee m >>=
		\r1 -> case r1 of
			Continue k -> return $ Continue ((>>= f) . k)
			Error err -> return $ Error err
			Yield x (Chunks []) -> runIteratee $ f x
			Yield x chunk -> runIteratee (f x) >>=
				\r2 -> case r2 of
					Continue k -> runIteratee $ k chunk
					Error err -> return $ Error err
					Yield x' _ -> return $ Yield x' chunk
:

The {\tt Functor} interface is a bit awkward, but since {\tt m} will almost
always be a monad the extra requirement is OK.

:d Data.Enumerator imports
import qualified Control.Applicative as A
import Control.Monad (liftM, ap)
:

:f Data/Enumerator.hs
instance Monad m => Functor (Iteratee a m) where
	fmap = liftM
	{-# INLINE fmap #-}

instance Monad m => A.Applicative (Iteratee a m) where
	pure = return
	{-# INLINE pure #-}
	
	(<*>) = ap
	{-# INLINE (<*>) #-}
:

Most iteratees are used to wrap I/O operations, so it's sensible to define
instances for typeclasses from {\tt transformers} and other related libraries.

:d Data.Enumerator imports
import qualified Control.Monad.IO.Class as MIO
import qualified Control.Monad.Trans.Class as MT
:

:f Data/Enumerator.hs
instance MT.MonadTrans (Iteratee a) where
	lift m = Iteratee $ m >>= runIteratee . return
	{-# INLINE lift #-}

instance MIO.MonadIO m => MIO.MonadIO (Iteratee a m) where
	liftIO = MT.lift . MIO.liftIO
	{-# INLINE liftIO #-}
:

To simplify dealing with monad transformers, liftTrans allows lifting an
iteratee's internal monad.

:f Data/Enumerator.hs
|apidoc liftTrans|
liftTrans :: (Monad m, MT.MonadTrans t, Monad (t m)) =>
             Iteratee a m b -> Iteratee a (t m) b
liftTrans iter = Iteratee $ do
	step <- MT.lift $ runIteratee iter
	return $ case step of
		Yield x cs -> Yield x cs
		Error err -> Error err
		Continue k -> Continue (liftTrans . k)
:

\section{Primitives}

:d Data.Enumerator exports
  -- * Primitives
:

\subsection{Combinators}

These are common patterns which occur whenever iteratees are being defined.

\filbreak

:f Data/Enumerator.hs
-- | @returnI x = Iteratee (return x)@
returnI :: Monad m => Step a m b -> Iteratee a m b
returnI = Iteratee . return
{-# INLINE returnI #-}

-- | @yield x chunk = returnI (Yield x chunk)@
yield :: Monad m => b -> Stream a -> Iteratee a m b
yield x chunk = returnI (Yield x chunk)
{-# INLINE yield #-}

-- | @continue k = returnI (Continue k)@
continue :: Monad m => (Stream a -> Iteratee a m b) -> Iteratee a m b
continue = returnI . Continue
{-# INLINE continue #-}

-- | @throwError err = returnI (Error err)@
throwError :: (Monad m, E.Exception e) => e -> Iteratee a m b
throwError = returnI . Error . E.toException
{-# INLINE throwError #-}

-- | @liftI f = continue (returnI . f)@
liftI :: Monad m => (Stream a -> Step a m b) -> Iteratee a m b
liftI k = continue $ returnI . k
{-# INLINE liftI #-}
:

:f Data/Enumerator.hs
catchError :: Monad m => Iteratee a m b -> (E.SomeException -> Iteratee a m b) -> Iteratee a m b
catchError iter h = Iteratee $ do
	step <- runIteratee iter
	case step of
		Error err -> runIteratee (h err)
		_ -> return step
:

These next two are equivalent to {\tt (>>=)} and {\tt (=<<)} respectively,
but allow iteratees with different input types to be composed. {\tt (==<<)}
is also aliased to {\tt (\$\$)}, to match Oleg's original code.

:f Data/Enumerator.hs
infixl 1 >>==

|apidoc (>>==)|
(>>==) :: Monad m =>
	Iteratee a m b ->
	(Step a m b -> Iteratee a' m b') ->
	Iteratee a' m b'
i >>== f = Iteratee $ runIteratee i >>= runIteratee . f
{-# INLINE (>>==) #-}
:

:f Data/Enumerator.hs
infixr 1 ==<<

|apidoc (==<<)|
(==<<):: Monad m =>
	(Step a m b -> Iteratee a' m b') ->
	Iteratee a m b ->
	Iteratee a' m b'
(==<<) = flip (>>==)
{-# INLINE (==<<) #-}
:

:f Data/Enumerator.hs
infixr 0 $$

|apidoc ($$)|
($$):: Monad m =>
	(Step a m b -> Iteratee a' m b') ->
	Iteratee a m b ->
	Iteratee a' m b'
($$) = (==<<)
{-# INLINE ($$) #-}
:

To make composing enumerators easier, equivalents to {\tt (>=>)} and
{\tt (<=<)} are defined.

:f Data/Enumerator.hs
infixr 1 >==>

|apidoc (>==>)|
(>==>) :: Monad m =>
	Enumerator a m b ->
	(Step a m b -> Iteratee a' m b') ->
	Step a m b ->
	Iteratee a' m b'
(>==>) e1 e2 s = e1 s >>== e2
{-# INLINE (>==>) #-}
:

:f Data/Enumerator.hs
infixr 1 <==<

|apidoc (<==<)|
(<==<) :: Monad m =>
	(Step a m b -> Iteratee a' m b') ->
	Enumerator a m b ->
	Step a m b ->
	Iteratee a' m b'
(<==<) = flip (>==>)
{-# INLINE (<==<) #-}
:

:d Data.Enumerator exports
  -- ** Combinators
  -- | These are common patterns which occur whenever iteratees are
  -- being defined.
, returnI
, yield
, continue
, throwError
, catchError
, liftI
, (>>==)
, (==<<)
, ($$)
, (>==>)
, (<==<)
:

\subsection{Iteratees}

:f Data/Enumerator.hs
|apidoc consume|
consume :: Monad m => Iteratee a m [a]
consume = liftI $ step id where
	step acc chunk = case chunk of
		Chunks [] -> Continue $ returnI . step acc
		Chunks xs -> Continue $ returnI . (step $ acc . (xs ++))
		EOF -> Yield (acc []) EOF
:

:f Data/Enumerator.hs
|apidoc isEOF|
isEOF :: Monad m => Iteratee a m Bool
isEOF = liftI $ \c -> case c of
	EOF -> Yield True c
	_   -> Yield False c
:

:f Data/Enumerator.hs
|apidoc liftFoldL|
liftFoldL :: Monad m => (b -> a -> b) -> b -> Iteratee a m b
liftFoldL f = liftI . step where
	step acc chunk = case chunk of
		Chunks [] -> Continue $ returnI . step acc
		Chunks xs -> Continue $ returnI . step (Prelude.foldl f acc xs)
		EOF -> Yield acc EOF
:

:d Data.Enumerator imports
import qualified Data.List as DataList
:

:f Data/Enumerator.hs
|apidoc liftFoldL'|
liftFoldL' :: Monad m => (b -> a -> b) -> b -> Iteratee a m b
liftFoldL' f = liftI . step where
	fold = DataList.foldl' f
	step acc chunk = case chunk of
		Chunks [] -> Continue $ returnI . step acc
		Chunks xs -> Continue $ returnI . (step $! fold acc xs)
		EOF -> Yield acc EOF
:

:d Data.Enumerator imports
import Control.Monad (foldM)
:

:f Data/Enumerator.hs
|apidoc liftFoldM|
liftFoldM :: Monad m => (b -> a -> m b) -> b -> Iteratee a m b
liftFoldM f = continue . step where
	step acc chunk = case chunk of
		Chunks [] -> continue $ step acc
		Chunks xs -> Iteratee $ liftM (Continue . step) (foldM f acc xs)
		EOF -> yield acc EOF
:

To simplify running iteratees, {\tt run} sends {\tt EOF} and then examines
the result. It is not possible for the result to be {\tt Continue}, because
{\tt enumEOF} calls {\tt error} for divergent iteratees.

:f Data/Enumerator.hs
|apidoc run|
run :: Monad m => Iteratee a m b -> m (Either E.SomeException b)
run i = do
	mStep <- runIteratee $ enumEOF ==<< i
	case mStep of
		Error err -> return $ Left err
		Yield x _ -> return $ Right x
		Continue _ -> error "run: divergent iteratee"
:

{\tt run\_} is even more simplified; it's used in simple scripts, where the
user doesn't care about error handling.

:f Data/Enumerator.hs
run_ :: Monad m => Iteratee a m b -> m b
run_ i = run i >>= either E.throw return
:

{\tt printChunks} is useful for debugging; it prints out exactly what input
it received, and optionally, any empty input chunks.

:f Data/Enumerator.hs
|apidoc printChunks|
printChunks :: (MIO.MonadIO m, Show a) => Bool -> Iteratee a m ()
printChunks printEmpty = continue step where
	step (Chunks []) | not printEmpty = continue step
	step (Chunks xs) = MIO.liftIO (print xs) >> continue step
	step EOF = MIO.liftIO (putStrLn "EOF") >> yield () EOF
:

:d Data.Enumerator exports
  -- ** Iteratees
, run
, run_
, consume
, isEOF
, liftTrans
, liftFoldL
, liftFoldL'
, liftFoldM
, printChunks
:

\subsection{Enumerators}

The most primitive enumerator;  simply sends {\tt EOF} to the iteratee. The
iteratee must either yield a value or throw an error -- continuing after EOF
will not terminate with any useful value.

:f Data/Enumerator.hs
|apidoc enumEOF|
enumEOF :: Monad m => Enumerator a m b
enumEOF (Yield x _) = yield x EOF
enumEOF (Error err) = throwError err
enumEOF (Continue k) = k EOF >>== check where
	check (Continue _) = error "enumEOF: divergent iteratee"
	check s = enumEOF s
:

Another small, useful enumerator separates an input list into chunks, and
sends them to the iteratee. This is useful for testing iteratees in pure
code.

:f Data/Enumerator.hs
|apidoc enumList|
enumList :: Monad m => Integer -> [a] -> Enumerator a m b
enumList n xs (Continue k) | not (null xs) = k chunk >>== loop where
	(s1, s2) = genericSplitAt n xs
	chunk = Chunks s1
	loop = enumList n s2
enumList _ _ step = returnI step
:

Sequencing a fixed set of enumerators is easy, but for more complex
cases, it's useful to have a small utility wrapper.

:f Data/Enumerator.hs
|apidoc concatEnums|
concatEnums :: Monad m => [Enumerator a m b] -> Enumerator a m b
concatEnums = foldl (>==>) returnI
{-# INLINE concatEnums #-}
:

:d Data.Enumerator exports
  -- ** Enumerators
, enumEOF
, enumList
, concatEnums
:

\subsection{Enumeratees}

{\tt joinI} is used to ``flatten'' enumeratees, to transform them into an
{\tt Iteratee}.

:f Data/Enumerator.hs
|apidoc joinI|
joinI :: Monad m => Iteratee a m (Step a' m b) -> Iteratee a m b
joinI outer = outer >>= check where
	check (Continue k) = k EOF >>== \s -> case s of
		Continue _ -> error "joinI: divergent iteratee"
		_ -> check s
	check (Yield x _) = return x
	check (Error e) = throwError e
:

A common pattern in {\tt Enumeratee} implementations is to check whether
the inner {\tt Iteratee} has finished, and if so, to return its output.
{\tt checkDone} passes its parameter a continuation if the {\tt Iteratee}
can still consume input, or yields otherwise.

:f Data/Enumerator.hs
|apidoc checkDone|
checkDone :: Monad m =>
	((Stream a -> Iteratee a m b) -> Iteratee a' m (Step a m b)) ->
	Enumeratee a' a m b
checkDone _ (Yield x chunk) = return $ Yield x chunk
checkDone f (Continue k) = f k
checkDone _ (Error err) = throwError err
{-# INLINE checkDone #-}
:

{\tt map} and {\tt sequence} are two simple enumeratees, which behave like
their namesakes from the Prelude. {\tt map} applies its transform to each
element of the stream, and {\tt sequence} repeatedly runs its parameter to
transform the stream.

:f Data/Enumerator.hs
|apidoc map|
map :: Monad m => (ao -> ai) -> Enumeratee ao ai m b
map f = loop where
	loop = checkDone $ continue . step
	step k EOF = yield (Continue k) EOF
	step k (Chunks []) = continue $ step k
	step k (Chunks xs) = k (Chunks (Prelude.map f xs)) >>== loop
:

:f Data/Enumerator.hs
|apidoc sequence|
sequence :: Monad m => Iteratee ao m ai -> Enumeratee ao ai m b
sequence i = loop where
	loop = checkDone check
	check k = isEOF >>= \f -> if f
		then yield (Continue k) EOF
		else step k
	step k = i >>= \v -> k (Chunks [v]) >>== loop
:

:d Data.Enumerator exports
  -- ** Enumeratees
, checkDone
, Data.Enumerator.map
, Data.Enumerator.sequence
, joinI
:

\section{Parser combinators}

Oleg's original {\tt IterateeM.hs} includes some basic iteratees for parsing,
so this section ports them to the new interface. However, in practice most
parsing will be performed with enumerator-based interfaces to Parsec or
Attoparsec.

:f Data/Enumerator.hs
|apidoc head|
head :: Monad m => Iteratee a m (Maybe a)
head = liftI step where
	step (Chunks []) = Continue $ returnI . step
	step (Chunks (x:xs)) = Yield (Just x) (Chunks xs)
	step EOF = Yield Nothing EOF
:

:f Data/Enumerator.hs
|apidoc peek|
peek :: Monad m => Iteratee a m (Maybe a)
peek = liftI step where
	step (Chunks []) = Continue $ returnI . step
	step chunk@(Chunks (x:_)) = Yield (Just x) chunk
	step chunk = Yield Nothing chunk
:

:f Data/Enumerator.hs
|apidoc last|
last :: Monad m => Iteratee a m (Maybe a)
last = liftI $ step Nothing where
	step ret (Chunks xs) = let
		ret' = case xs of
			[] -> ret
			_  -> Just $ Prelude.last xs
		in Continue $ returnI . step ret'
	step ret EOF = Yield ret EOF
:

:f Data/Enumerator.hs
|apidoc length|
length :: Monad m => Iteratee a m Integer
length = liftI $ step 0 where
	step n (Chunks xs) = Continue $ returnI . step (n + genericLength xs)
	step n EOF = Yield n EOF
:

:f Data/Enumerator.hs
|apidoc drop|
drop :: Monad m => Integer -> Iteratee a m ()
drop 0 = return ()
drop n = liftI $ step n where
	step n' (Chunks xs)
		| len xs < n' = Continue $ returnI . step (n' - len xs)
		| otherwise   = Yield () $ Chunks $ genericDrop n' xs
	step _ EOF = Yield () EOF
	len = genericLength
:

:f Data/Enumerator.hs
|apidoc dropWhile|
dropWhile :: Monad m => (a -> Bool) -> Iteratee a m ()
dropWhile p = liftI step where
	step (Chunks xs) = case Prelude.dropWhile p xs of
		[] -> Continue $ returnI . step
		xs' -> Yield () $ Chunks xs'
	step EOF = Yield () EOF
:

:f Data/Enumerator.hs
|apidoc span|
span :: Monad m => (a -> Bool) -> Iteratee a m [a]
span f = liftI $ step [] where
	step acc (Chunks xs) = case Prelude.span f xs of
		(_, []) -> Continue $ returnI . step (acc ++ xs)
		(head', tail') -> Yield (acc ++ head') (Chunks tail')
	step acc EOF = Yield acc EOF

|apidoc break|
break :: Monad m => (a -> Bool) -> Iteratee a m [a]
break p = span $ not . p
:

:d Data.Enumerator exports
  -- * Parser combinators
  |apidoc parser combinators|
, Data.Enumerator.head
, peek
, Data.Enumerator.last
, Data.Enumerator.length
, Data.Enumerator.drop
, Data.Enumerator.dropWhile
, span
, Data.Enumerator.break
:

\section{IO}

:f Data/Enumerator/IO.hs
|Data.Enumerator.IO module header|
module Data.Enumerator.IO
	( enumHandle
	, enumFile
	, iterHandle
	) where
import Data.Enumerator
import Data.Enumerator.Util
import Control.Monad.IO.Class (MonadIO)
import qualified Control.Exception as E
import qualified Data.ByteString as B
import qualified System.IO as IO
import System.IO.Error (isEOFError)
:

:f Data/Enumerator/IO.hs
|apidoc enumHandle|
enumHandle :: MonadIO m
           => Integer -- ^ Buffer size
           -> IO.Handle
           -> Enumerator B.ByteString m b
enumHandle bufferSize h = Iteratee . loop where
	loop (Continue k) = withBytes $ \bytes -> if B.null bytes
		then return $ Continue k
		else runIteratee (k (Chunks [bytes])) >>= loop
	
	loop step = return step
	
	intSize = fromInteger bufferSize
	withBytes = tryStep $ do
		hasInput <- E.catch
			(IO.hWaitForInput h (-1))
			(\err -> if isEOFError err
				then return False
				else E.throwIO err)
		if hasInput
			then B.hGetNonBlocking h intSize
			else return B.empty
:

:f Data/Enumerator/IO.hs
|apidoc enumFile|
enumFile :: FilePath -> Enumerator B.ByteString IO b
enumFile path s = Iteratee io where
	withHandle = tryStep (IO.openBinaryFile path IO.ReadMode)
	io = withHandle $ \h -> E.finally
		(runIteratee (enumHandle 4096 h s))
		(IO.hClose h)
:

:f Data/Enumerator/IO.hs
|apidoc iterHandle|
iterHandle :: MonadIO m => IO.Handle -> Iteratee B.ByteString m ()
iterHandle h = continue step where
	step EOF = yield () EOF
	step (Chunks []) = continue step
	step (Chunks bytes) = Iteratee io where
		put = mapM_ (B.hPut h) bytes
		io = tryStep put (\_ -> return $ Continue step)
:

\section{Text handling}

:f Data/Enumerator/Text.hs
|Data.Enumerator.Text module header|
module Data.Enumerator.Text (
	|Data.Enumerator.Text exports|
	) where
|Data.Enumerator.Text imports|
import Data.Enumerator
import Data.Enumerator.Util
:

\subsection{Text IO}

:d Data.Enumerator.Text exports
  -- * Enumerators and iteratees
  enumHandle
, enumFile
, iterHandle
:

:d Data.Enumerator.Text imports
import Control.Monad.IO.Class (MonadIO)
import qualified Control.Exception as E
import qualified Data.Text as T
import qualified Data.Text.IO as T
import qualified System.IO as IO
import System.IO.Error (isEOFError)
:

:f Data/Enumerator/Text.hs
|apidoc enumHandle (text)|
enumHandle :: MonadIO m => IO.Handle -> Enumerator T.Text m b
enumHandle h = Iteratee . loop where
	loop (Continue k) = withText $ \maybeText -> case maybeText of
		Nothing -> return $ Continue k
		Just text -> runIteratee (k (Chunks [text])) >>= loop
	
	loop step = return step
	withText = tryStep $ E.catch
		(Just `fmap` T.hGetLine h)
		(\err -> if isEOFError err
			then return Nothing
			else E.throwIO err)
:

:f Data/Enumerator/Text.hs
|apidoc enumFile (text)|
enumFile :: FilePath -> Enumerator T.Text IO b
enumFile path s = Iteratee io where
	withHandle = tryStep (IO.openFile path IO.ReadMode)
	io = withHandle $ \h -> E.finally
		(runIteratee (enumHandle h s))
		(IO.hClose h)
:

:f Data/Enumerator/Text.hs
|apidoc iterHandle (text)|
iterHandle :: MonadIO m => IO.Handle -> Iteratee T.Text m ()
iterHandle h = continue step where
	step EOF = yield () EOF
	step (Chunks []) = continue step
	step (Chunks chunks) = Iteratee io where
		put = mapM_ (T.hPutStr h) chunks
		io = tryStep put (\_ -> return $ Continue step)
:

\subsection{Text codecs}

:d Data.Enumerator.Text exports
  -- * Codecs
, Codec
, encode
, decode
|text codec exports|
:

:d Data.Enumerator.Text imports
import Control.Arrow (first)
import Data.Bits ((.&.))
import qualified Data.ByteString as B
import qualified Data.ByteString.Char8 as B8
import qualified Data.Text.Encoding as TE
:

:f Data/Enumerator/Text.hs
|apidoc Codec|
data Codec = Codec
	{ codecName :: T.Text
	, codecEncode :: [T.Text] -> Either E.SomeException [B.ByteString]
	, codecDecode :: B.ByteString -> Either E.SomeException (T.Text, B.ByteString)
	}

instance Show Codec where
	showsPrec d c = showParen (d > 10) $
		showString "Codec " . shows (codecName c)
:

:f Data/Enumerator/Text.hs
|apidoc encode|
encode :: Monad m => Codec -> Enumeratee T.Text B.ByteString m b
encode codec = loop where
	loop = checkDone $ continue . step
	step k EOF = yield (Continue k) EOF
	step k (Chunks []) = continue $ step k
	step k (Chunks xs) = case codecEncode codec xs of
		Left err -> throwError err
		Right byteChunks -> k (Chunks byteChunks) >>== loop
:

:f Data/Enumerator/Text.hs
|apidoc decode|
decode :: Monad m => Codec -> Enumeratee B.ByteString T.Text m b
decode codec = loop B.empty where
	dec = codecDecode codec
	
	loop acc = checkDone $ continue . step acc
	step acc k EOF = yield (Continue k) $ if B.null acc
		then EOF
		else Chunks [acc]
	step acc k (Chunks []) = continue $ step acc k
	step acc k (Chunks xs) = case dec (B.concat (acc:xs)) of
		Left err -> throwError err
		Right (text, extra) -> if T.null text
			then continue $ step extra k
			else k (Chunks [text]) >>== loop extra
:

\subsubsection{UTF-8}

:d text codec exports
, utf8
:

:f Data/Enumerator/Text.hs
utf8 :: Codec
utf8 = Codec name enc dec where
	name = T.pack "UTF-8"
	enc = Right . Prelude.map TE.encodeUtf8
	dec = unsafeTryDec . splitBytes
	|utf8 split bytes|
:

:d utf8 split bytes
splitBytes bytes = loop 0 where
	|utf8 required bytes count|
	maxN = B.length bytes
	
	loop n | n == maxN = (TE.decodeUtf8 bytes, B.empty)
	loop n = let
		req = required $ B.index bytes n
		tooLong = first TE.decodeUtf8 $ B.splitAt n bytes
		decodeMore = loop $! n + req
		in if req > maxN then tooLong else decodeMore
:

:d utf8 required bytes count
required x0
	| x0 .&. 0x80 == 0x00 = 1
	| x0 .&. 0xE0 == 0xC0 = 2
	| x0 .&. 0xF0 == 0xE0 = 3
	| x0 .&. 0xF8 == 0xF0 = 4
	
	-- Invalid input; let Text figure it out
	| otherwise           = 1
:

\subsubsection{UTF-16}

:d text codec exports
, utf16_le
, utf16_be
:

:d Data.Enumerator.Text imports
import Data.Bits ((.|.), shiftL)
import Data.Word (Word16)
:

:f Data/Enumerator/Text.hs
utf16_le :: Codec
utf16_le = Codec name enc dec where
	name = T.pack "UTF-16-LE"
	enc = Right . Prelude.map TE.encodeUtf16LE
	dec = unsafeTryDec . splitBytes
	|utf16-le split bytes|
:

:f Data/Enumerator/Text.hs
utf16_be :: Codec
utf16_be = Codec name enc dec where
	name = T.pack "UTF-16-BE"
	enc = Right . Prelude.map TE.encodeUtf16BE
	dec = unsafeTryDec . splitBytes
	|utf16-be split bytes|
:

:d utf16-le split bytes
splitBytes bytes = loop 0 where
	maxN = B.length bytes
	
	loop n |  n      == maxN = (TE.decodeUtf16LE bytes, B.empty)
	       | (n + 1) == maxN = decodeTo n
	loop n = let
		req = utf16Required (B.index bytes 0) (B.index bytes 1)
		decodeMore = loop $! n + req
		in if req > maxN then decodeTo n else decodeMore
	
	decodeTo n = first TE.decodeUtf16LE $ B.splitAt n bytes
:

:d utf16-be split bytes
splitBytes bytes = loop 0 where
	maxN = B.length bytes
	
	loop n |  n      == maxN = (TE.decodeUtf16BE bytes, B.empty)
	       | (n + 1) == maxN = decodeTo n
	loop n = let
		req = utf16Required (B.index bytes 1) (B.index bytes 0)
		decodeMore = loop $! n + req
		in if req > maxN then decodeTo n else decodeMore
	
	decodeTo n = first TE.decodeUtf16BE $ B.splitAt n bytes
:

:f Data/Enumerator/Text.hs
utf16Required :: Word8 -> Word8 -> Int
utf16Required x0 x1 = required where
	required = if x >= 0xD800 && x <= 0xDBFF
		then 4
		else 2
	x :: Word16
	x = (fromIntegral x1 `shiftL` 8) .|. fromIntegral x0
:

\subsubsection{UTF-32}

:d text codec exports
, utf32_le
, utf32_be
:

:f Data/Enumerator/Text.hs
utf32_le :: Codec
utf32_le = Codec name enc dec where
	name = T.pack "UTF-32-LE"
	enc = Right . Prelude.map TE.encodeUtf32LE
	dec = unsafeTryDec . utf32SplitBytes TE.decodeUtf32LE
	

utf32_be :: Codec
utf32_be = Codec name enc dec where
	name = T.pack "UTF-32-BE"
	enc = Right . Prelude.map TE.encodeUtf32BE
	dec = unsafeTryDec . utf32SplitBytes TE.decodeUtf32BE
:

:f Data/Enumerator/Text.hs
utf32SplitBytes :: (B.ByteString -> a) -> B.ByteString -> (a, B.ByteString)
utf32SplitBytes dec bytes = (dec toDecode, extra) where
	len = B.length bytes
	lenExtra = mod len 4
	lenToDecode = len - lenExtra
	(toDecode, extra) = if lenExtra == 0
		then (bytes, B.empty)
		else B.splitAt lenToDecode bytes
:

\subsubsection{ASCII}

:d text codec exports
, ascii
:

:f Data/Enumerator/Text.hs
ascii :: Codec
ascii = Codec name (mapEither enc) dec where
	name = T.pack "ASCII"
	enc t = case T.findBy (\c -> ord c > 0x7F) t of
		Nothing -> Right . B8.pack . T.unpack $ t
		Just c -> illegalEnc name c
	dec bytes = case B.find (\w -> w > 0x7F) bytes of
		Nothing -> Right (T.pack (B8.unpack bytes), B.empty)
		Just w -> illegalDec name w
:

\subsubsection{ISO 8859-1}

:d text codec exports
, iso8859_1
:

:f Data/Enumerator/Text.hs
iso8859_1 :: Codec
iso8859_1 = Codec name (mapEither enc) dec where
	name = T.pack "ISO-8859-1"
	enc t = case T.findBy (\c -> ord c > 0xFF) t of
		Nothing -> Right . B8.pack . T.unpack $ t
		Just c -> illegalEnc name c
	dec bytes = Right (T.pack (B8.unpack bytes), B.empty)
:

\subsection{Text utility functions}

:d Data.Enumerator.Text imports
import Prelude as Prelude
import Numeric (showIntAtBase)
import Data.Char (toUpper, intToDigit, ord)
import Data.Word (Word8)
import System.IO.Unsafe (unsafePerformIO)
:

:f Data/Enumerator/Text.hs
illegalEnc :: T.Text -> Char -> Either E.SomeException a
illegalEnc name c = Left . E.toException . E.ErrorCall $ msg "" where
	len = Prelude.length
	pad str | len str < 4 = replicate (4 - len str) '0' ++ str
	        | otherwise      = str
	hex = "U+" ++ pad (showIntAtBase 16 (toUpper . intToDigit) (ord c) "")
	msg = (s "Codec " . shows name . s " can't encode character " . s hex)
	s = showString
:

:f Data/Enumerator/Text.hs
illegalDec :: T.Text -> Word8 -> Either E.SomeException a
illegalDec name w = Left . E.toException . E.ErrorCall $ msg "" where
	len = Prelude.length
	pad str | len str < 2 = replicate (2 - len str) '0' ++ str
	        | otherwise      = str
	hex = "0x" ++ pad (showIntAtBase 16 (toUpper . intToDigit) w "")
	msg = (s "Codec " . shows name . s " can't decode byte " . s hex)
	s = showString
:

:f Data/Enumerator/Text.hs
unsafeTryDec :: (a, b) -> Either E.SomeException (a, b)
unsafeTryDec (a, b) = unsafePerformIO $ do
	tried <- E.try $ E.evaluate a
	return $ case tried of
		Left err -> Left err
		Right _ -> Right (a, b)
:

\section{Misc. utilities}

:f Data/Enumerator/Util.hs
module Data.Enumerator.Util where
import Data.Enumerator
import Control.Monad.IO.Class (MonadIO, liftIO)
import qualified Control.Exception as E

tryStep :: MonadIO m => IO t -> (t -> m (Step a m b)) -> m (Step a m b)
tryStep get io = do
	tried <- liftIO (E.try get)
	case tried of
		Right t -> io t
		Left err -> return $ Error err
{-# INLINE tryStep #-}

mapEither :: (a -> Either e b) -> [a] -> Either e [b]
mapEither f = loop [] where
	loop acc [] = Right (reverse acc)
	loop acc (a:as) = case f a of
		Left err -> Left err
		Right b -> loop (b:acc) as
{-# INLINE mapEither #-}
:

\section{Haddock API documentation}

This section just repeats literate documentation in Haddock syntax.

:d Data.Enumerator module header
-----------------------------------------------------------------------------
-- |
-- Module: Data.Enumerator
-- Copyright: 2010 John Millikin
-- License: MIT
--
-- Maintainer: jmillikin@gmail.com
-- Portability: portable
--
-- An implementation of Oleg Kiselyov&#x2019;s left-fold enumerators
--
-----------------------------------------------------------------------------
:

:d apidoc Stream
-- | Not to be confused with types from the @Stream@ or
-- @stream-fusion@ packages, a 'Stream' is a sequence of chunks
-- generated by an 'Enumerator'. In contrast to Oleg&#x2019;s implementation,
-- this stream does not support error handling -- errors encountered
-- while generating a stream are reported in the 'Step' type instead.
--
-- @(Chunks [])@ is used to indicate that a stream is still active, but
-- currently has no available data. Iteratees should ignore empty chunks.
:

:d apidoc Step.Continue
-- | The 'Iteratee' is capable of accepting more input. Note that more input
-- is not necessarily required; the 'Iteratee' might be able to generate a
-- value immediately if it receives 'EOF'.
:

:d apidoc Step.Yield
-- | The 'Iteratee' has received enough input to generate a result.
-- Included in this value is left-over input, which can be passed to
-- composed 'Iteratee's.
:

:d apidoc Step.Error
-- | The 'Iteratee' encountered an error which prevents it from proceeding
-- further.
:

:d apidoc Iteratee
-- | The primary data type for this library, which consumes
-- input from a 'Stream' until it either generates a value or encounters
-- an error. Rather than requiring all input at once, an iteratee will
-- return 'Continue' when it is capable of processing more data.
--
-- In general, iteratees begin in the 'Continue' state. As each chunk is
-- passed to the continuation, the iteratee returns the next step:
-- 'Continue' for more data, 'Yield' when it's finished, or 'Error' to
-- abort processing.
:

:d apidoc Enumerator
-- | While 'Iteratee's consume data, enumerators generate it. Since
-- @'Iteratee'@ is an alias for @m ('Step' a m b)@, 'Enumerator's can
-- be considered step transformers of type
-- @'Step' a m b -> m ('Step' a m b)@.
--
-- 'Enumerator's typically read from an external source (parser, handle,
-- random generator, etc). They feed chunks into an 'Iteratee' until the
-- source runs out of data (triggering 'EOF') or the iteratee finishes
-- processing ('Yield's a value).
:

:d apidoc Enumeratee
-- | In cases where an enumerator acts as both a source and sink, the resulting
-- type is named an 'Enumeratee'. Enumeratees have two input types,
-- &#x201c;outer a&#x201d; (@aOut@) and &#x201c;inner a&#x201d; (@aIn@).
:

:d apidoc liftTrans
-- | Lift an 'Iteratee' onto a monad transformer, re-wrapping the
-- 'Iteratee'&#x2019;s inner monadic values.
:

:d apidoc (>>==)
-- | Equivalent to (>>=), but allows 'Iteratee's with different input types
-- to be composed.
:

:d apidoc (==<<)
-- | @(==\<\<) = flip (\>\>==)@
:

:d apidoc ($$)
-- | @($$) = (==\<\<)@
--
-- This might be easier to read when passing a chain of iteratees to an
-- enumerator.
:

:d apidoc (>==>)
-- | @(>==>) e1 e2 s = e1 s >>== e2@
:

:d apidoc (<==<)
-- | @(\<==\<) = flip (>==>)@
:

:d apidoc consume
-- | Consume all input until 'EOF', then return consumed input as a list.
:

:d apidoc isEOF
-- | Return 'True' if the next 'Stream' is 'EOF'.
:

:d apidoc liftFoldL
-- | Lifts a pure left fold into an iteratee.
:

:d apidoc liftFoldL'
-- | As 'liftFoldL', but strict in its accumulator.
:

:d apidoc liftFoldM
-- | Lifts a monadic left fold into an iteratee.
:

:d apidoc enumEOF
-- | The most primitive enumerator; simply sends 'EOF'. The iteratee must
-- either yield a value or throw an error continuing receiving 'EOF' will
-- not terminate with any useful value.
:

:d apidoc enumList
-- | Another small, useful enumerator separates an input list into chunks,
-- and sends them to the iteratee. This is useful for testing iteratees in pure
-- code.
:

:d apidoc concatEnums
-- | Compose a list of 'Enumerator's using '(>>==)'
:

:d apidoc joinI
-- | 'joinI' is used to &#x201C;flatten&#x201D; 'Enumeratee's into an
-- 'Iteratee'.
:

:d apidoc checkDone
-- | A common pattern in 'Enumeratee' implementations is to check whether
-- the inner 'Iteratee' has finished, and if so, to return its output.
-- 'checkDone' passes its parameter a continuation if the 'Iteratee'
-- can still consume input, or yields otherwise.
:

API docs for these are still TODO

:d apidoc map
:

:d apidoc sequence
:

:d apidoc head
:

:d apidoc peek
:

:d apidoc last
:

:d apidoc length
:

:d apidoc drop
:

:d apidoc dropWhile
:

:d apidoc span
:

:d apidoc break
-- | @break p = 'span' (not . p)@
:

:d apidoc parser combinators
-- | Oleg&#x2019;s original @IterateeM.hs@ includes some basic iteratees
-- for parsing, so this section ports them to the new interface. However,
-- in practice most parsing will be performed with enumerator-based
-- interfaces to existing parser libraries (such as Parsec or Attoparsec).
:

:d apidoc run
-- | Run an iteratee until it finishes, and return either the final value
-- (if it succeeded) or the error (if it failed).
:

:d apidoc printChunks
-- | Print chunks as they're received from the enumerator, optionally
-- printing empty chunks.
:

:d Data.Enumerator.IO module header
-----------------------------------------------------------------------------
-- |
-- Module: Data.Enumerator.IO
-- Copyright: 2010 John Millikin
-- License: MIT
--
-- Maintainer: jmillikin@gmail.com
-- Portability: portable
--
-- Enumerator-based IO
--
-----------------------------------------------------------------------------
:

:d apidoc enumHandle
-- | Read bytes (in chunks of the given buffer size) from the handle, and
-- stream them to an 'Iteratee'. If an exception occurs during file IO,
-- enumeration will stop and 'Error' will be returned. Exceptions from the
-- iteratee are not caught.
--
-- This enumerator blocks until at least one byte is available from the
-- handle, and might read less than the maximum buffer size in some
-- cases.
--
-- The handle should be opened with no encoding, and in 'IO.ReadMode' or
-- 'IO.ReadWriteMode'.
:

:d apidoc iterHandle
-- | Read bytes from a stream and write them to a handle. If an exception
-- occurs during file IO, enumeration will stop and 'Error' will be
-- returned.
--
-- The handle should be opened with no encoding, and in 'IO.WriteMode' or
-- 'IO.ReadWriteMode'.
:

:d apidoc enumFile
-- | Opens a file path in binary mode, and passes the handle to 'enumHandle'.
-- The file will be closed when the 'Iteratee' finishes.
:

:d Data.Enumerator.Text module header
-----------------------------------------------------------------------------
-- |
-- Module: Data.Enumerator.Text
-- Copyright: 2010 John Millikin
-- License: MIT
--
-- Maintainer: jmillikin@gmail.com
-- Portability: portable
--
-- Enumerator-based text IO
--
-----------------------------------------------------------------------------
:

:d apidoc enumHandle (text)
-- | Read lines of text from the handle, and stream them to an 'Iteratee'.
-- If an exception occurs during file IO, enumeration will stop and 'Error'
-- will be returned. Exceptions from the iteratee are not caught.
--
-- The handle should be opened with an appropriate text encoding, and
-- in 'IO.ReadMode' or 'IO.ReadWriteMode'.
:

:d apidoc iterHandle (text)
-- | Read text from a stream and write it to a handle. If an exception
-- occurs during file IO, enumeration will stop and 'Error' will be
-- returned.
--
-- The handle should be opened with an appropriate text encoding, and
-- in 'IO.WriteMode' or 'IO.ReadWriteMode'.
:

:d apidoc enumFile (text)
-- | Opens a file path in text mode, and passes the handle to 'enumHandle'.
-- The file will be closed when the 'Iteratee' finishes.
:

:d apidoc Codec
:

:d apidoc encode
:

:d apidoc decode
:

\end{document}
