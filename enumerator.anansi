:# Copyright (C) 2010 John Millikin <jmillikin@gmail.com>
:#
:# See license.txt for details

\documentclass[10pt,twocolumn]{article}

\usepackage{color}
\usepackage{hyperref}
\usepackage{noweb}
\usepackage{indentfirst}
\usepackage[compact]{titlesec}
\usepackage{amsmath}

\noweboptions{smallcode}

:# Smaller margins
\usepackage[left=1cm,top=1cm,right=1cm,nohead,nofoot]{geometry}

:# Remove boxes from hyperlinks
\hypersetup{
    colorlinks,
    linkcolor=blue,
}

\setlength{\parindent}{0.5cm}
\setlength{\parskip}{0.15cm}

\titlespacing{\section}{0pt}{*0}{*0}
\titlespacing{\subsection}{0pt}{*0}{*0}

\pagestyle{empty}

\newcommand{\io}{{\sc i/o}}

\title{enumerator\_0.4.5}
\author{John Millikin}
\date{2010-12-24}

\begin{document}

\maketitle

\section*{Abstract}

Typical buffer-based incremental \io{} is based around a single loop, which
reads data from some source (such as a socket or file), transforms it, and
generates one or more outputs (such as a line count, {\sc http} responses,
or modified file).  Although efficient and safe, these loops are all
single-purpose; it is difficult or impossible to compose buffer-based
processing loops.

Haskell's concept of ``lazy \io{}'' allows pure code to operate on data from
an external source. However, lazy \io{} has several shortcomings. Most notably,
resources such as memory and file handles can be retained for arbitrarily
long periods of time, causing unpredictable performance and error conditions.

Enumerators are an efficient, predictable, and safe alternative to lazy \io{}.
Discovered by Oleg \mbox{Kiselyov}, they allow large datasets to be processed
in near-constant space by pure code. Although somewhat more complex to write,
using enumerators instead of lazy \io{} produces more correct programs.

This library contains an enumerator implementation for Haskell, designed to
be both simple and efficient.

\section{Overview}

This library defines three core types, and numerous helper functions to
work with them. The types are:

{\it Iteratee\/}: Data sinks, analogous to {\tt foldl}. Iteratees consume
a sequence of \emph{input} values, and generate a single \emph{output} value.
Many iteratees are designed to perform side effects (such as printing to
{\tt stdout}), so they can also be used as monad transformers.

{\it Enumerator\/}: Data sources, which generate input sequences. Typical
enumerators read from a file handle, socket, random number generator, or
other external stream. To operate, enumerators are passed an iteratee, and
provide that iteratee with input until either the iteratee has completed its
computation, or {\sc eof}.

{\it Enumeratee\/}: Data transformers, which operate as both enumerators and
iteratees. Enumeratees read from an \emph{outer} enumerator, and provide the
transformed data to an \emph{inner} iteratee.

Most of this library's types and functions are exported from the
{\tt Data.Enumerator} module.

:f Data/Enumerator.hs
|Data.Enumerator module header|
module Data.Enumerator (
	|Data.Enumerator exports|
	) where
|Data.Enumerator imports|
:

A few utility functions share names with functions from the Prelude, so
those are removed from the default namespace.

:d Data.Enumerator imports
import qualified Prelude as Prelude
import Prelude hiding (
	|excluded Prelude imports|
	)
:

\section{Type definitions}

:d Data.Enumerator exports
  -- * Types
  Stream (..)
, Iteratee (..)
, Step (..)
, Enumerator
, Enumeratee
:

\subsection{Input streams}

A {\tt Stream} is a sequence of chunks generated by an enumerator or
enumeratee. Chunks might be composite values, such as a string, or atomic,
such as a parser event. Allowing a stream to support multiple chunks
slightly complicates iteratee and enumeratee implementation, but greatly
simplifies handling of leftover inputs.

{\tt (Chunks [])} is a legal value, used when a stream is still active but
no data is currently available. Iteratees and enumeratees often special-case
empty chunks for performance reasons, though they're not required to.

:f Data/Enumerator.hs
|apidoc Stream|
data Stream a
	= Chunks [a]
	| EOF
	deriving (Show, Eq)

instance Monad Stream where
	return = Chunks . return
	Chunks xs >>= f = mconcat (fmap f xs)
	EOF >>= _ = EOF

instance Functor Stream where
	fmap f (Chunks xs) = Chunks (fmap f xs)
	fmap _ EOF = EOF

instance A.Applicative Stream where
	pure = return
	(<*>) = CM.ap
:

The {\tt Monoid} instance deserves some special attention, because it has
the unexpected behavior that {\tt mappend EOF (Chunks []) == EOF}. Although
it's reasonable that appending chunks to an {\sc eof} stream should provide
a valid stream, such behavior would violate the monoid laws.

:d Data.Enumerator imports
import Data.Monoid (Monoid, mempty, mappend, mconcat)
:

:f Data/Enumerator.hs
instance Monoid (Stream a) where
	mempty = Chunks mempty
	mappend (Chunks xs) (Chunks ys) = Chunks (xs ++ ys)
	mappend _ _ = EOF
:

\subsection{Iteratees}

The primary data type for this library is {\tt Iteratee}, which consumes
input until it either generates a value or encounters an error. Rather
than requiring all input at once, an iteratee will return {\tt Continue}
when it is capable of processing more data.

In general, iteratees begin in the {\tt Continue} state. As each chunk is
passed to the continuation, the iteratee may return the next step, which is
one of:

\begin{itemize}
\item {\tt Continue}: The iteratee is capable of accepting more input. Note
that more input is not required; the iteratee might be able to generate a
value immediately if the stream ends.

\item {\tt Yield}: The iteratee has received enough input to generate a
result. Included in this value is left-over input, which can be passed to
the next iteratee.

\item {\tt Error}: The iteratee encountered an error which prevents it from
proceeding further.
\end{itemize}

:d Data.Enumerator imports
import qualified Control.Exception as Exc
:

:f Data/Enumerator.hs
data Step a m b
	|apidoc Step.Continue|
	= Continue (Stream a -> Iteratee a m b)
	
	|apidoc Step.Yield|
	| Yield b (Stream a)
	
	|apidoc Step.Error|
	| Error Exc.SomeException

|apidoc Iteratee|
newtype Iteratee a m b = Iteratee
	{ runIteratee :: m (Step a m b)
	}
:

Users often need to construct iteratees which only yield or continue,
so we define some helper functions to save typing:

:f Data/Enumerator.hs
|apidoc returnI|
returnI :: Monad m => Step a m b -> Iteratee a m b
returnI step = Iteratee (return step)

|apidoc yield|
yield :: Monad m => b -> Stream a -> Iteratee a m b
yield x extra = returnI (Yield x extra)

|apidoc continue|
continue :: Monad m => (Stream a -> Iteratee a m b)
         -> Iteratee a m b
continue k = returnI (Continue k)
:

:d Data.Enumerator exports
, returnI
, yield
, continue
:

\subsection{Enumerators}

Enumerators typically read from an external source (parser, handle, random
number generator, etc). They feed chunks into an iteratee until the source
runs out of data (triggering {\tt EOF}) or the iteratee finishes processing
(yields a value).

Since {\tt Iteratee} is an alias for {\tt m (Step a m b)}, enumerators can
also be considered step transformers of type
{\tt Step a m b -> m (Step a m b)}.

:f Data/Enumerator.hs
|apidoc Enumerator|
type Enumerator a m b = Step a m b -> Iteratee a m b
:

Although enumerators can be encoded as a simple step transformer with the
type {\tt Step a m b -> Step a m b}, encoding as a computation allows easier
reasoning about the order of side effects. Consider the case of enumerating
two files:

:d enumerator example
let iterFoo = enumFile "foo.txt" iterWhatever
let iterBar = enumFile "bar.txt" iterFoo
:

It's impossible to determine, merely by looking at these lines, which file
will be opened first. In fact, depending on the implementation of
{\tt enumFile}, both files might be open at the same time. If enumerators
return monadic values, the order of events is more clear:

:d enumerator example
iterFoo <- enumFile "foo.txt" iterWhatever
iterBar <- enumFile "bar.txt" iterFoo
:

\subsection{Enumeratees}

In cases where an enumerator acts as both a source and sink, the resulting
type is named an {\tt Enumeratee}. Enumeratees have two input types,
``outer a'' ({\tt ao}) and ``inner a'' ({\tt ai}).

Enumeratees are encoded as an iteratee stack. The outer iteratee reads from
a stream of \emph{ao} values, transforms them into \emph{ai}, and passes them
to an inner iteratee. This model allows a single outer input to generate many
inner inputs, and vice-versa.

:f Data/Enumerator.hs
type Enumeratee ao ai m b = Step ai m b
          -> Iteratee ao m (Step ai m b)
:

\subsection{Operators}

Because {\tt Iteratee a m b} is semantically equivalent to
{\tt m (Step a m b)}, several of the monadic combinators ({\tt (>>=)},
{\tt (>=>)}, etc) are useful to save typing when constructing enumerators
and enumeratees. {\tt (>>==)} corresponds to {\tt (>>=)}, {\tt (>==>)} to
{\tt (>=>)}, and so on.

For compatibility, {\tt (==<<)} is aliased to {\tt (\$\$)}.

:f Data/Enumerator.hs
infixl 1 >>==

|apidoc (>>==)|
(>>==) :: Monad m =>
	Iteratee a m b ->
	(Step a m b -> Iteratee a' m b') ->
	Iteratee a' m b'
i >>== f = Iteratee (runIteratee i >>= runIteratee . f)
:

:f Data/Enumerator.hs
infixr 1 ==<<

|apidoc (==<<)|
(==<<):: Monad m =>
	(Step a m b -> Iteratee a' m b') ->
	Iteratee a m b ->
	Iteratee a' m b'
(==<<) = flip (>>==)
:

:f Data/Enumerator.hs
infixr 0 $$

|apidoc ($$)|
($$):: Monad m =>
	(Step a m b -> Iteratee a' m b') ->
	Iteratee a m b ->
	Iteratee a' m b'
($$) = (==<<)
:

:f Data/Enumerator.hs
infixr 1 >==>

|apidoc (>==>)|
(>==>) :: Monad m =>
	Enumerator a m b ->
	(Step a m b -> Iteratee a' m b') ->
	Step a m b ->
	Iteratee a' m b'
(>==>) e1 e2 s = e1 s >>== e2
:

:f Data/Enumerator.hs
infixr 1 <==<

|apidoc (<==<)|
(<==<) :: Monad m =>
	(Step a m b -> Iteratee a' m b') ->
	Enumerator a m b ->
	Step a m b ->
	Iteratee a' m b'
(<==<) = flip (>==>)
:

:d Data.Enumerator exports
, (>>==)
, (==<<)
, ($$)
, (>==>)
, (<==<)
:

\section{Iteratees as Monads}

Iteratees are monads; by sequencing iteratees, very complex processing may
be applied to arbitrary input streams. Iteratees are also applicative
functors and monad transformers.

:f Data/Enumerator.hs
instance Monad m => Monad (Iteratee a m) where
	return x = yield x (Chunks [])
	
	m >>= f = Iteratee $ runIteratee m >>=
		\r1 -> case r1 of
			Continue k -> return (Continue ((>>= f) . k))
			Error err -> return (Error err)
			Yield x (Chunks []) -> runIteratee (f x)
			Yield x extra -> runIteratee (f x) >>=
				\r2 -> case r2 of
					Continue k -> runIteratee (k extra)
					Error err -> return (Error err)
					Yield x' _ -> return (Yield x' extra)
:

Most iteratees are used to wrap \io{} operations, so it's sensible to define
instances for typeclasses from {\tt transformers}.

:d Data.Enumerator imports
import Control.Monad.Trans.Class (MonadTrans, lift)
import Control.Monad.IO.Class (MonadIO, liftIO)
:

:f Data/Enumerator.hs
instance MonadTrans (Iteratee a) where
	lift m = Iteratee (m >>= runIteratee . return)

instance MonadIO m => MonadIO (Iteratee a m) where
	liftIO = lift . liftIO
:

It's probably possible to define {\tt Functor} and {\tt Applicative}
instances for {\tt Iteratee} without a {\tt Monad} constraint, but I haven't
bothered, since every useful operation requires {\tt m} to be a Monad anyway.

:d Data.Enumerator imports
import qualified Control.Applicative as A
import qualified Control.Monad as CM
:

:f Data/Enumerator.hs
instance Monad m => Functor (Iteratee a m) where
	fmap = CM.liftM
:

:f Data/Enumerator.hs
instance Monad m => A.Applicative (Iteratee a m) where
	pure = return
	(<*>) = CM.ap
:

\section{Error handling}

Most real-world applications have to deal with error conditions; however,
libraries have various ways of reporting errors. Some throw exceptions,
others use callbacks, and many just use {\tt Either}. Heterogeneous error
handling makes composing code very difficult; therefore, all
enumerator-based code simply uses the standard {\tt Control.Exception}
module and its types.

Instances for the {\tt MonadError} class are provided in auxiliary
libraries, to avoid extraneous dependencies.

:f Data/Enumerator.hs
|apidoc throwError|
throwError :: (Monad m, Exc.Exception e) => e
           -> Iteratee a m b
throwError exc = returnI (Error (Exc.toException exc))
:

Handling errors has a caveat: any input consumed before the error was
thrown can't be recovered. If an iteratee needs to continue parsing after an
error, either buffer the input stream or use a separate framing mechanism.

This limitation means that {\tt catchError} is mostly only useful for
transforming or logging errors, not ignoring them.

:f Data/Enumerator.hs
catchError :: Monad m => Iteratee a m b
           -> (Exc.SomeException -> Iteratee a m b)
           -> Iteratee a m b
catchError iter h = iter >>== step where
	step (Yield b as) = yield b as
	step (Error err) = h err
	step (Continue k) = continue (\s -> k s >>== step)
:

:d Data.Enumerator exports
, throwError
, catchError
:

\section{Primitives}

\subsection{Iteratees}

\subsubsection{Folds}

Since iteratees are semantically a left-fold, there are many existing
folds that can be lifted to iteratees. The {\tt foldl}, {\tt foldl'}, and
{\tt foldM} functions work like their standard library namesakes, but
construct iteratees instead. These iteratees are not as complex as what can
be created using {\tt Yield} and {\tt Continue}, but cover many common cases.

Each fold consumes input from the stream until {\sc eof}, when it yields its
current accumulator.

:d Data.Enumerator imports
import Data.List (foldl')
:

:f Data/Enumerator.hs
|apidoc foldl|
foldl :: Monad m => (b -> a -> b) -> b
      -> Iteratee a m b
foldl step = continue . loop where
	fold = Prelude.foldl step
	loop acc stream = case stream of
		Chunks [] -> continue (loop acc)
		Chunks xs -> continue (loop (fold acc xs))
		EOF -> yield acc EOF
:

:f Data/Enumerator.hs
|apidoc foldl'|
foldl' :: Monad m => (b -> a -> b) -> b
       -> Iteratee a m b
foldl' step = continue . loop where
	fold = Data.List.foldl' step
	loop acc stream = case stream of
		Chunks [] -> continue (loop acc)
		Chunks xs -> continue (loop (fold acc xs))
		EOF -> yield acc EOF
:

:f Data/Enumerator.hs
|apidoc foldM|
foldM :: Monad m => (b -> a -> m b) -> b
      -> Iteratee a m b
foldM step = continue . loop where
	fold acc = lift . CM.foldM step acc
	
	loop acc stream = case stream of
		Chunks [] -> continue (loop acc)
		Chunks xs -> fold acc xs >>= continue . loop
		EOF -> yield acc EOF
:

:d Data.Enumerator exports
, Data.Enumerator.foldl
, Data.Enumerator.foldl'
, Data.Enumerator.foldM
:

\subsubsection{Debugging}

Debugging enumerator-based code is mostly a question of what inputs are
being passed around. {\tt consume} allows the entire stream to be read
into a list, and {\tt printChunks} prints out exactly what chunks are
being sent from an enumerator.

:f Data/Enumerator.hs
|apidoc consume|
consume :: Monad m => Iteratee a m [a]
consume = continue (loop id) where
	loop acc stream = case stream of
		Chunks [] -> continue (loop acc)
		Chunks xs -> continue (loop (acc . (xs ++)))
		EOF -> yield (acc []) EOF
:

:f Data/Enumerator.hs
|apidoc printChunks|
printChunks :: (MonadIO m, Show a) => Bool
            -> Iteratee a m ()
printChunks printEmpty = continue loop where
	loop (Chunks xs) = do
		let hide = null xs && not printEmpty
		CM.unless hide (liftIO (print xs))
		continue loop
	
	loop EOF = do
		liftIO (putStrLn "EOF")
		yield () EOF
:

:d Data.Enumerator exports
, consume
, printChunks
:

\subsection{Enumerators}

At their simplest, enumerators just check to see whether their received step
can accept any more input. If so, input is generated somehow, fed to the step,
and its result checked again. Most enumerators are defined using a
worker/wrapper pair, for efficiency and readability.

Here we define a number of enumerators based on functions from
{\tt Data.List}. Each generator has a monadic and non-monadic form, to
demonstrate how side effects might be ordered with respect to the iteratee's
processing.

{\tt iterate} and {\tt iterateM} apply a function repeatedly to the base
input, passing the results through as a stream.

:f Data/Enumerator.hs
iterate :: Monad m => (a -> a) -> a -> Enumerator a m b
iterate f = loop where
	loop a (Continue k) = k (Chunks [a]) >>== loop (f a)
	loop _ step = returnI step
:

:f Data/Enumerator.hs
iterateM :: Monad m => (a -> m a) -> a
         -> Enumerator a m b
iterateM f base = loop (return base) where
	loop m_a (Continue k) = do
		a <- lift m_a
		k (Chunks [a]) >>== loop (f a)
	loop _ step = returnI step
:

{\tt repeat} and {\tt repeatM} create infinite streams, where each input
is a single value.

:f Data/Enumerator.hs
repeat :: Monad m => a -> Enumerator a m b
repeat a = Data.Enumerator.iterate (const a) a
:

:f Data/Enumerator.hs
repeatM :: Monad m => m a -> Enumerator a m b
repeatM m_a step = do
	a <- lift m_a
	iterateM (const m_a) a step
:

{\tt replicate} and {\tt replicateM} create streams containing a given
quantity of the input value.

:f Data/Enumerator.hs
replicateM :: Monad m => Integer -> m a
           -> Enumerator a m b
replicateM maxCount getNext = loop maxCount where
	loop 0 step = returnI step
	loop n (Continue k) = do
		next <- lift getNext
		k (Chunks [next]) >>== loop (n - 1)
	loop _ step = returnI step
:

:f Data/Enumerator.hs
replicate :: Monad m => Integer -> a
          -> Enumerator a m b
replicate maxCount a = replicateM maxCount (return a)
:

{\tt generateM} runs a monadic computation until it returns {\tt Nothing},
which signals the end of enumeration.

Note that when the enumerator is finished, it does not send {\tt EOF} to
the iteratee. Instead, it returns a continuation, so additional enumerators
may add their own input to the stream.

:f Data/Enumerator.hs
generateM :: Monad m => m (Maybe a)
          -> Enumerator a m b
generateM getNext = loop where
	loop (Continue k) = do
		next <- lift getNext
		case next of
			Nothing -> continue k
			Just x -> k (Chunks [x]) >>== loop
	loop step = returnI step
:

:d Data.Enumerator exports
, Data.Enumerator.iterate
, iterateM
, Data.Enumerator.repeat
, repeatM
, Data.Enumerator.replicate
, replicateM
, generateM
:

\subsection{Enumeratees}

Enumeratees are conceptually similar to a monadic {\tt concatMap}; each
outer input element is converted to a list of inner inputs, which are passed
to the inner iteratee. Error handling and performance considerations
make most real-life enumeratees more complex, but some don't need the extra
design.

The {\tt checkDone} and {\tt checkDoneEx} functions referenced here are
defined later, with other utilities.

:f Data/Enumerator.hs
concatMapM :: Monad m => (ao -> m [ai])
           -> Enumeratee ao ai m b
concatMapM f = checkDone (continue . step) where
	step k EOF = yield (Continue k) EOF
	step k (Chunks xs) = loop k xs
	
	loop k [] = continue (step k)
	loop k (x:xs) = do
		fx <- lift (f x)
		k (Chunks fx) >>==
			checkDoneEx (Chunks xs) (\k' -> loop k' xs)
:

Once {\tt concatMapM} is defined, similar enumeratees can be easily created
via small wrappers.

:d excluded Prelude imports
concatMap,
:

:f Data/Enumerator.hs
concatMap :: Monad m => (ao -> [ai])
          -> Enumeratee ao ai m b
concatMap f = concatMapM (return . f)
:

:f Data/Enumerator.hs
map :: Monad m => (ao -> ai)
    -> Enumeratee ao ai m b
map f = concatMap (\x -> Prelude.map f [x])
:

:f Data/Enumerator.hs
filter :: Monad m => (a -> Bool)
       -> Enumeratee a a m b
filter p = concatMap (\x -> Prelude.filter p [x])
:

:f Data/Enumerator.hs
mapM :: Monad m => (ao -> m ai)
     -> Enumeratee ao ai m b
mapM f = concatMapM (\x -> Prelude.mapM f [x])
:

:f Data/Enumerator.hs
filterM :: Monad m => (a -> m Bool)
        -> Enumeratee a a m b
filterM p = concatMapM (\x -> CM.filterM p [x])
:

:d Data.Enumerator exports
, Data.Enumerator.map
, Data.Enumerator.concatMap
, Data.Enumerator.filter
, Data.Enumerator.mapM
, concatMapM
, Data.Enumerator.filterM
:

\section{IO}

The core use case for enumerators is parsing data from a file or socket.
As more input becomes available, it's read from the handle and run through
the iteratee stack.

Any exceptions thrown while reading or writing data are caught and reported
using {\tt throwError}, so errors can be handled in pure iteratees.

:d io module imports
import Data.Enumerator
import Data.Enumerator.Util
import Control.Monad.IO.Class (MonadIO)
import qualified Control.Exception as Exc
import qualified System.IO as IO
import System.IO.Error (isEOFError)
import qualified Data.ByteString as B
:

\subsection{Binary IO}

{\tt enumHandle} and {\tt enumFile} are rough analogues of
{\tt hGetContents} and {\tt readFile} from the standard library, except
they operate only in binary mode.

:f Data/Enumerator/IO.hs
|Data.Enumerator.IO module header|
module Data.Enumerator.IO
	( enumHandle
	, enumFile
	, iterHandle
	) where
|io module imports|
:

:f Data/Enumerator/IO.hs
|apidoc enumHandle|
enumHandle :: MonadIO m
           => Integer -- ^ Buffer size
           -> IO.Handle
           -> Enumerator B.ByteString m b
enumHandle bufferSize h = loop where
	loop (Continue k) = withBytes $ \bytes ->
		if B.null bytes
			then continue k
			else k (Chunks [bytes]) >>== loop
	
	loop step = returnI step
	
	intSize = fromInteger bufferSize
	withBytes = tryStep $ do
		hasInput <- Exc.catch
			(IO.hWaitForInput h (-1))
			(\err -> if isEOFError err
				then return False
				else Exc.throwIO err)
		if hasInput
			then B.hGetNonBlocking h intSize
			else return B.empty
:

:f Data/Enumerator/IO.hs
|apidoc enumFile|
enumFile :: FilePath -> Enumerator B.ByteString IO b
enumFile path = enum where
	withHandle = tryStep (IO.openBinaryFile path IO.ReadMode)
	enum step = withHandle $ \h -> do
		Iteratee $ Exc.finally
			(runIteratee (enumHandle 4096 h step))
			(IO.hClose h)
:

:f Data/Enumerator/IO.hs
|apidoc iterHandle|
iterHandle :: MonadIO m => IO.Handle
           -> Iteratee B.ByteString m ()
iterHandle h = continue step where
	step EOF = yield () EOF
	step (Chunks []) = continue step
	step (Chunks bytes) = let
		put = mapM_ (B.hPut h) bytes
		in tryStep put (\_ -> continue step)
:

\subsection{Text IO}

Reading text is similar, but the enumerators have slightly different
behavior -- instead of reading in fixed-size chunks of data, the text
enumerators read in lines. This matches similar text-based {\sc api}s,
such as Python's {\tt xreadlines()}.

:f Data/Enumerator/Text.hs
|Data.Enumerator.Text module header|
module Data.Enumerator.Text
	( enumHandle
	, enumFile
	, iterHandle
	|Data.Enumerator.Text exports|
	) where
|io module imports|
|Data.Enumerator.Text imports|
import qualified Data.Text as T
import qualified Data.Text.IO as T
:

:f Data/Enumerator/Text.hs
|apidoc enumHandle (text)|
enumHandle :: MonadIO m => IO.Handle
           -> Enumerator T.Text m b
enumHandle h = loop where
	loop (Continue k) = withText $ \maybeText ->
		case maybeText of
			Nothing -> continue k
			Just text -> k (Chunks [text]) >>== loop
	
	loop step = returnI step
	withText = tryStep $ Exc.catch
		(Just `fmap` T.hGetLine h)
		(\err -> if isEOFError err
			then return Nothing
			else Exc.throwIO err)
:

:f Data/Enumerator/Text.hs
|apidoc enumFile (text)|
enumFile :: FilePath -> Enumerator T.Text IO b
enumFile path = enum where
	withHandle = tryStep (IO.openFile path IO.ReadMode)
	enum step = withHandle $ \h -> Iteratee $ Exc.finally
		(runIteratee (enumHandle h step))
		(IO.hClose h)
:

:f Data/Enumerator/Text.hs
|apidoc iterHandle (text)|
iterHandle :: MonadIO m => IO.Handle
           -> Iteratee T.Text m ()
iterHandle h = continue step where
	step EOF = yield () EOF
	step (Chunks []) = continue step
	step (Chunks chunks) = let
		put = mapM_ (T.hPutStr h) chunks
		in tryStep put (\_ -> continue step)
:

\section{Text codecs}

Many protocols need the non-blocking input behavior of binary \io{}, but
are defined in terms of unicode characters. The {\tt encode} and
{\tt decode} enumeratees allow text-based protocols to be easily parsed
from a binary input source.

Most common codecs ({\sc utf-8}, {\sc iso-8859-1}, {\sc ascii}) are
supported; more complex codecs can be implemented by bindings to libraries
such as libicu.

All of the codecs here are incremental; that is, they try to read as much
data as possible, but no more. This allows iteratees to read partial data
if the input stream contains invalid data.

:d Data.Enumerator.Text exports
  -- * Codecs
, Codec
, encode
, decode
|text codec exports|
:

:f Data/Enumerator/Text.hs
|apidoc Codec|
data Codec = Codec
	{ codecName :: T.Text
	, codecEncode
		:: T.Text
		-> (B.ByteString, Maybe (Exc.SomeException, T.Text))
	, codecDecode
		:: B.ByteString
		-> (T.Text, Either
			(Exc.SomeException, B.ByteString)
			B.ByteString)
	}

instance Show Codec where
	showsPrec d c = showParen (d > 10) $
		showString "Codec " . shows (codecName c)
:

:f Data/Enumerator/Text.hs
|apidoc encode|
encode :: Monad m => Codec
       -> Enumeratee T.Text B.ByteString m b
encode codec = checkDone (continue . step) where
	step k EOF = yield (Continue k) EOF
	step k (Chunks xs) = loop k xs
	
	loop k [] = continue (step k)
	loop k (x:xs) = let
		(bytes, extra) = codecEncode codec x
		extraChunks = Chunks $ case extra of
			Nothing -> xs
			Just (_, text) -> text:xs
		
		checkError k' = case extra of
			Nothing -> loop k' xs
			Just (exc, _) -> throwError exc
		
		in if B.null bytes
			then checkError k
			else k (Chunks [bytes]) >>==
				checkDoneEx extraChunks checkError
:

:f Data/Enumerator/Text.hs
|apidoc decode|
decode :: Monad m => Codec
       -> Enumeratee B.ByteString T.Text m b
decode codec = checkDone (continue . step B.empty) where
	step _   k EOF = yield (Continue k) EOF
	step acc k (Chunks xs) = loop acc k xs
	
	loop acc k [] = continue (step acc k)
	loop acc k (x:xs) = let
		(text, extra) = codecDecode codec (B.append acc x)
		extraChunks = Chunks (either snd id extra : xs)
		
		checkError k' = case extra of
			Left (exc, _) -> throwError exc
			Right bytes -> loop bytes k' xs
		
		in if T.null text
			then checkError k
			else k (Chunks [text]) >>==
				checkDoneEx extraChunks checkError
:

Most of the codecs here need to perform at least basic bitbashing, to
calculate how many input bytes will be needed for the next character.

:d Data.Enumerator.Text imports
import Control.Arrow (first)
import Data.Bits ((.&.), (.|.), shiftL)
import Data.Char (ord)
import Data.Word (Word8, Word16)
import qualified Data.ByteString.Char8 as B8
import qualified Data.Text.Encoding as TE
:

The variable-width decoders all follow the same basic pattern. First,
they examine their input to calculate how many bytes the decoder
function should accept. Next they try to decode it -- if the input
is valid, decoding is finished.

If the input is invalid, trying to decode the full input will throw
an exception. When an exception is caught, decoding is passed off to
{\tt splitSlowly} for a more careful parse. The input is reduced until
the decoder can parse something, and the rest of the bytes are stored
for later. An error will only be thrown if the iteratee requires input,
but there are no valid bytes remaining.

:f Data/Enumerator/Text.hs
byteSplits :: B.ByteString -> [(B.ByteString, B.ByteString)]
byteSplits bytes = loop (B.length bytes) where
	loop 0 = [(B.empty, bytes)]
	loop n = B.splitAt n bytes : loop (n - 1)
:

:d Data.Enumerator.Text imports
import Data.Maybe (catMaybes)
:

:f Data/Enumerator/Text.hs
splitSlowly :: (B.ByteString -> T.Text)
            -> B.ByteString
            -> (T.Text, Either
            	(Exc.SomeException, B.ByteString)
            	B.ByteString)
splitSlowly dec bytes = valid where
	valid = firstValid (Prelude.map decFirst splits)
	splits = byteSplits bytes
	firstValid = Prelude.head . catMaybes
	tryDec = tryEvaluate . dec
	
	decFirst (a, b) = case tryDec a of
		Left _ -> Nothing
		Right text -> Just (text, case tryDec b of
			Left exc -> Left (exc, b)
			
			-- this case shouldn't occur, since splitSlowly
			-- is only called when parsing failed somewhere
			Right _ -> Right B.empty)
:

\subsection{UTF-8}

:d text codec exports
, utf8
:

:f Data/Enumerator/Text.hs
utf8 :: Codec
utf8 = Codec name enc dec where
	name = T.pack "UTF-8"
	enc text = (TE.encodeUtf8 text, Nothing)
	dec bytes = case splitQuickly bytes of
		Just (text, extra) -> (text, Right extra)
		Nothing -> splitSlowly TE.decodeUtf8 bytes
	|utf8 split bytes|
:

:d utf8 split bytes
splitQuickly bytes = loop 0 >>= maybeDecode where
	|utf8 required bytes count|
	maxN = B.length bytes
	
	loop n | n == maxN = Just (TE.decodeUtf8 bytes, B.empty)
	loop n = let
		req = required (B.index bytes n)
		tooLong = first TE.decodeUtf8 (B.splitAt n bytes)
		decodeMore = loop $! n + req
		in if req == 0
			then Nothing
			else if n + req > maxN
				then Just tooLong
				else decodeMore
:

:d utf8 required bytes count
required x0
	| x0 .&. 0x80 == 0x00 = 1
	| x0 .&. 0xE0 == 0xC0 = 2
	| x0 .&. 0xF0 == 0xE0 = 3
	| x0 .&. 0xF8 == 0xF0 = 4
	
	-- Invalid input; let Text figure it out
	| otherwise           = 0
:

\subsection{UTF-16}

:d text codec exports
, utf16_le
, utf16_be
:

:f Data/Enumerator/Text.hs
utf16_le :: Codec
utf16_le = Codec name enc dec where
	name = T.pack "UTF-16-LE"
	enc text = (TE.encodeUtf16LE text, Nothing)
	dec bytes = case splitQuickly bytes of
		Just (text, extra) -> (text, Right extra)
		Nothing -> splitSlowly TE.decodeUtf16LE bytes
	|utf16-le split bytes|
:

:f Data/Enumerator/Text.hs
utf16_be :: Codec
utf16_be = Codec name enc dec where
	name = T.pack "UTF-16-BE"
	enc text = (TE.encodeUtf16BE text, Nothing)
	dec bytes = case splitQuickly bytes of
		Just (text, extra) -> (text, Right extra)
		Nothing -> splitSlowly TE.decodeUtf16BE bytes
	|utf16-be split bytes|
:

:d utf16-le split bytes
splitQuickly bytes = maybeDecode (loop 0) where
	maxN = B.length bytes
	
	loop n |  n      == maxN = decodeAll
	       | (n + 1) == maxN = decodeTo n
	loop n = let
		req = utf16Required
			(B.index bytes 0)
			(B.index bytes 1)
		decodeMore = loop $! n + req
		in if n + req > maxN
			then decodeTo n
			else decodeMore
	
	decodeTo n = first TE.decodeUtf16LE (B.splitAt n bytes)
	decodeAll = (TE.decodeUtf16LE bytes, B.empty)
:

:d utf16-be split bytes
splitQuickly bytes = maybeDecode (loop 0) where
	maxN = B.length bytes
	
	loop n |  n      == maxN = decodeAll
	       | (n + 1) == maxN = decodeTo n
	loop n = let
		req = utf16Required
			(B.index bytes 1)
			(B.index bytes 0)
		decodeMore = loop $! n + req
		in if n + req > maxN
			then decodeTo n
			else decodeMore
	
	decodeTo n = first TE.decodeUtf16BE (B.splitAt n bytes)
	decodeAll = (TE.decodeUtf16BE bytes, B.empty)
:

:f Data/Enumerator/Text.hs
utf16Required :: Word8 -> Word8 -> Int
utf16Required x0 x1 = required where
	required = if x >= 0xD800 && x <= 0xDBFF
		then 4
		else 2
	x :: Word16
	x = (fromIntegral x1 `shiftL` 8) .|. fromIntegral x0
:

\subsection{UTF-32}

:d text codec exports
, utf32_le
, utf32_be
:

:f Data/Enumerator/Text.hs
utf32_le :: Codec
utf32_le = Codec name enc dec where
	name = T.pack "UTF-32-LE"
	enc text = (TE.encodeUtf32LE text, Nothing)
	dec bs = case utf32SplitBytes TE.decodeUtf32LE bs of
		Just (text, extra) -> (text, Right extra)
		Nothing -> splitSlowly TE.decodeUtf32LE bs

utf32_be :: Codec
utf32_be = Codec name enc dec where
	name = T.pack "UTF-32-BE"
	enc text = (TE.encodeUtf32BE text, Nothing)
	dec bs = case utf32SplitBytes TE.decodeUtf32BE bs of
		Just (text, extra) -> (text, Right extra)
		Nothing -> splitSlowly TE.decodeUtf32BE bs
:

:f Data/Enumerator/Text.hs
utf32SplitBytes :: (B.ByteString -> T.Text)
                -> B.ByteString
                -> Maybe (T.Text, B.ByteString)
utf32SplitBytes dec bytes = split where
	split = maybeDecode (dec toDecode, extra)
	len = B.length bytes
	lenExtra = mod len 4
	
	lenToDecode = len - lenExtra
	(toDecode, extra) = if lenExtra == 0
		then (bytes, B.empty)
		else B.splitAt lenToDecode bytes
:

\subsection{ASCII}

:d text codec exports
, ascii
:

:f Data/Enumerator/Text.hs
ascii :: Codec
ascii = Codec name enc dec where
	name = T.pack "ASCII"
	enc text = (bytes, extra) where
		(safe, unsafe) = textSpanBy (\c -> ord c <= 0x7F) text
		bytes = B8.pack (T.unpack safe)
		extra = if T.null unsafe
			then Nothing
			else Just (illegalEnc name (T.head unsafe), unsafe)
	
	dec bytes = (text, extra) where
		(safe, unsafe) = B.span (<= 0x7F) bytes
		text = T.pack (B8.unpack safe)
		extra = if B.null unsafe
			then Right B.empty
			else Left (illegalDec name (B.head unsafe), unsafe)
:

\subsection{ISO 8859-1}

:d text codec exports
, iso8859_1
:

:f Data/Enumerator/Text.hs
iso8859_1 :: Codec
iso8859_1 = Codec name enc dec where
	name = T.pack "ISO-8859-1"
	enc text = (bytes, extra) where
		(safe, unsafe) = textSpanBy (\c -> ord c <= 0xFF) text
		bytes = B8.pack (T.unpack safe)
		extra = if T.null unsafe
			then Nothing
			else Just (illegalEnc name (T.head unsafe), unsafe)
	
	dec bytes = (T.pack (B8.unpack bytes), Right B.empty)
:

\subsection{Encoding Utilities}

:f Data/Enumerator/Text.hs
illegalEnc :: T.Text -> Char -> Exc.SomeException
illegalEnc name c = Exc.toException . Exc.ErrorCall $
	concat [ "Codec "
	       , show name
	       , " can't encode character "
	       , reprChar c
	       ]
:

:f Data/Enumerator/Text.hs
illegalDec :: T.Text -> Word8 -> Exc.SomeException
illegalDec name w = Exc.toException . Exc.ErrorCall $
	concat [ "Codec "
	       , show name
	       , " can't decode byte  "
	       , reprWord w
	       ]
:

:d Data.Enumerator.Text imports
import System.IO.Unsafe (unsafePerformIO)
:

:f Data/Enumerator/Text.hs
tryEvaluate :: a -> Either Exc.SomeException a
tryEvaluate = unsafePerformIO . Exc.try . Exc.evaluate

maybeDecode:: (a, b) -> Maybe (a, b)
maybeDecode (a, b) = case tryEvaluate a of
	Left _ -> Nothing
	Right _ -> Just (a, b)
:

\section{Parser combinators}

Oleg's original {\tt IterateeM.hs} includes some basic iteratees for parsing,
so this section ports them to the new interface. However, in practice most
parsing will be performed with enumerator-based interfaces to Parsec or
Attoparsec.

:f Data/Enumerator.hs
|apidoc head|
head :: Monad m => Iteratee a m (Maybe a)
head = continue loop where
	loop (Chunks []) = continue loop
	loop (Chunks (x:xs)) = yield (Just x) (Chunks xs)
	loop EOF = yield Nothing EOF
:

:f Data/Enumerator.hs
|apidoc peek|
peek :: Monad m => Iteratee a m (Maybe a)
peek = continue loop where
	loop (Chunks []) = continue loop
	loop chunk@(Chunks (x:_)) = yield (Just x) chunk
	loop EOF = yield Nothing EOF
:

:f Data/Enumerator.hs
|apidoc last|
last :: Monad m => Iteratee a m (Maybe a)
last = continue (loop Nothing) where
	loop ret (Chunks xs) = continue . loop $ case xs of
		[] -> ret
		_ -> Just (Prelude.last xs)
	loop ret EOF = yield ret EOF
:

:f Data/Enumerator.hs
|apidoc length|
length :: Monad m => Iteratee a m Integer
length = continue (loop 0) where
	len = genericLength
	loop n (Chunks xs) = continue (loop (n + len xs))
	loop n EOF = yield n EOF
:

:f Data/Enumerator.hs
|apidoc drop|
drop :: Monad m => Integer -> Iteratee a m ()
drop 0 = return ()
drop n = continue (loop n) where
	len = genericLength
	loop n' (Chunks xs)
		| len xs < n' = continue (loop (n' - len xs))
		| otherwise   = yield () (Chunks (genericDrop n' xs))
	loop _ EOF = yield () EOF
:

:f Data/Enumerator.hs
|apidoc dropWhile|
dropWhile :: Monad m => (a -> Bool) -> Iteratee a m ()
dropWhile p = continue loop where
	loop (Chunks xs) = case Prelude.dropWhile p xs of
		[] -> continue loop
		xs' -> yield () (Chunks xs')
	loop EOF = yield () EOF
:

:f Data/Enumerator.hs
|apidoc span|
span :: Monad m => (a -> Bool) -> Iteratee a m [a]
span p = continue (loop []) where
	loop acc (Chunks xs) = case Prelude.span p xs of
		(_, []) -> continue (loop (acc ++ xs))
		(head', tail') -> yield (acc ++ head') (Chunks tail')
	loop acc EOF = yield acc EOF

|apidoc break|
break :: Monad m => (a -> Bool) -> Iteratee a m [a]
break p = Data.Enumerator.span (not . p)
:

:d Data.Enumerator exports
, Data.Enumerator.head
, peek
, Data.Enumerator.last
, Data.Enumerator.length
, Data.Enumerator.drop
, Data.Enumerator.dropWhile
, Data.Enumerator.span
, Data.Enumerator.break
:

\section{Misc. utilities}

A few special-case utilities that are used by similar libraries, or were
present in previous versions of {\tt enumerator}, or otherwise don't have a
good place to go.

\subsection{Running iteratees}

To simplify running iteratees, {\tt run} sends {\tt EOF} and then examines
the result. It is not possible for the result to be {\tt Continue}, because
{\tt enumEOF} calls {\tt error} for divergent iteratees.

:f Data/Enumerator.hs
|apidoc run|
run :: Monad m => Iteratee a m b
    -> m (Either Exc.SomeException b)
run i = do
	mStep <- runIteratee $ enumEOF ==<< i
	case mStep of
		Error err -> return $ Left err
		Yield x _ -> return $ Right x
		Continue _ -> error "run: divergent iteratee"
:

:f Data/Enumerator.hs
|apidoc enumEOF|
enumEOF :: Monad m => Enumerator a m b
enumEOF (Yield x _) = yield x EOF
enumEOF (Error err) = throwError err
enumEOF (Continue k) = k EOF >>== check where
	check (Continue _) = error "enumEOF: divergent iteratee"
	check s = enumEOF s
:

{\tt run\_} is even more simplified; it's used in simple scripts, where the
user doesn't care about error handling.

:f Data/Enumerator.hs
run_ :: Monad m => Iteratee a m b -> m b
run_ i = run i >>= either Exc.throw return
:

:d Data.Enumerator exports
, enumEOF
, run
, run_
:

\subsection{{\tt checkDone} and {\tt checkDoneEx}}

A common pattern in {\tt Enumeratee} implementations is to check whether
the inner {\tt Iteratee} has finished, and if so, to return its output.
{\tt checkDone} passes its parameter a continuation if the {\tt Iteratee}
can still consume input, or yields otherwise.

Oleg's version of {\tt checkDone} has a problem---when the enumeratee has
some sort of input buffer, but the underlying iteratee enters {\tt Yield},
it will discard the output buffer. {\tt checkDoneEx} corrects this; for
backwards compatibility, {\tt checkDone} remains.

:f Data/Enumerator.hs
|apidoc checkDoneEx|
checkDoneEx :: Monad m =>
	Stream a' ->
	((Stream a -> Iteratee a m b) -> Iteratee a' m (Step a m b)) ->
	Enumeratee a' a m b
checkDoneEx _     f (Continue k) = f k
checkDoneEx extra _ step         = yield step extra

|apidoc checkDone|
checkDone :: Monad m =>
	((Stream a -> Iteratee a m b) -> Iteratee a' m (Step a m b)) ->
	Enumeratee a' a m b
checkDone = checkDoneEx (Chunks [])
:

:f Data/Enumerator.hs
|apidoc liftTrans|
liftTrans :: (Monad m, MonadTrans t, Monad (t m)) =>
             Iteratee a m b -> Iteratee a (t m) b
liftTrans iter = Iteratee $ do
	step <- lift (runIteratee iter)
	return $ case step of
		Yield x cs -> Yield x cs
		Error err -> Error err
		Continue k -> Continue (liftTrans . k)
:

:f Data/Enumerator.hs
|apidoc liftI|
liftI :: Monad m => (Stream a -> Step a m b) -> Iteratee a m b
liftI k = continue (\stream -> returnI (k stream))
:

:d Data.Enumerator exports
, checkDone
, checkDoneEx
, liftTrans
, liftI
:

\subsection{other}

Another small, useful enumerator separates an input list into chunks, and
sends them to the iteratee. This is useful for testing iteratees in pure
code.

:d Data.Enumerator imports
import Data.List (genericSplitAt, genericLength, genericDrop)
:

:f Data/Enumerator.hs
|apidoc enumList|
enumList :: Monad m => Integer -> [a] -> Enumerator a m b
enumList n xs (Continue k) | not (null xs) = k chunk >>== loop where
	(s1, s2) = genericSplitAt n xs
	chunk = Chunks s1
	loop = enumList n s2
enumList _ _ step = returnI step
:

Sequencing a fixed set of enumerators is easy, but for more complex
cases, it's useful to have a small utility wrapper.

:f Data/Enumerator.hs
|apidoc concatEnums|
concatEnums :: Monad m => [Enumerator a m b] -> Enumerator a m b
concatEnums = Prelude.foldl (>==>) returnI
:

:d Data.Enumerator exports
, enumList
, concatEnums
:

\subsection{Enumeratees}

{\tt joinI} is used to ``flatten'' enumeratees, to transform them into an
{\tt Iteratee}.

:f Data/Enumerator.hs
|apidoc joinI|
joinI :: Monad m => Iteratee a m (Step a' m b) -> Iteratee a m b
joinI outer = outer >>= check where
	check (Continue k) = k EOF >>== \s -> case s of
		Continue _ -> error "joinI: divergent iteratee"
		_ -> check s
	check (Yield x _) = return x
	check (Error e) = throwError e
:

{\tt sequence} repeatedly runs its parameter to transform the stream.

:f Data/Enumerator.hs
|apidoc sequence|
sequence :: Monad m => Iteratee ao m ai -> Enumeratee ao ai m b
sequence i = loop where
	loop = checkDone check
	check k = isEOF >>= \f -> if f
		then yield (Continue k) EOF
		else step k
	step k = i >>= \v -> k (Chunks [v]) >>== loop
:

:f Data/Enumerator.hs
|apidoc isEOF|
isEOF :: Monad m => Iteratee a m Bool
isEOF = continue $ \s -> case s of
	EOF -> yield True s
	_ -> yield False s
:

:d Data.Enumerator exports
, joinI
, Data.Enumerator.sequence
, isEOF
:

{\tt Data.Enumerator.Util} is a hidden module for functions used by several
public modules, but not logically part of the {\tt enumerator} API.

:f Data/Enumerator/Util.hs
{-# LANGUAGE CPP #-}
module Data.Enumerator.Util where
import Data.Enumerator

import Data.Char (toUpper, intToDigit, ord)
import Data.Word (Word8)
import qualified Data.Text as T

import Control.Monad.IO.Class (MonadIO, liftIO)
import qualified Control.Exception as Exc
import Numeric (showIntAtBase)
:

:f Data/Enumerator/Util.hs
tryStep :: MonadIO m => IO t -> (t -> Iteratee a m b) -> Iteratee a m b
tryStep get io = do
	tried <- liftIO (Exc.try get)
	case tried of
		Right t -> io t
		Left err -> throwError (err :: Exc.SomeException)
:

:f Data/Enumerator/Util.hs
pad0 :: Int -> String -> String
pad0 size str = padded where
	len = Prelude.length str
	padded = if len >= size
		then str
		else Prelude.replicate (size - len) '0' ++ str
:

:f Data/Enumerator/Util.hs
reprChar :: Char -> String
reprChar c = "U+" ++ (pad0 4 (showIntAtBase 16 (toUpper . intToDigit) (ord c) ""))
:

:f Data/Enumerator/Util.hs
reprWord :: Word8 -> String
reprWord w = "0x" ++ (pad0 2 (showIntAtBase 16 (toUpper . intToDigit) w ""))
:

{\tt text-0.11} changed some function names to appease a few bikeshedding
idiots in -cafe; to support it, a bit of compatibility code is needed.

I had a choice between using the preprocessor, or a separate module plus
some Cabal magic. It turns out that {\tt cabal sdist} doesn't properly
handle multiple source directories selected by flags, so the preprocessor
is used for now.

:f Data/Enumerator/Util.hs
textSpanBy :: (Char -> Bool) -> T.Text -> (T.Text, T.Text)
#if MIN_VERSION_text(0,11,0)
textSpanBy = T.span
#else
textSpanBy = T.spanBy
#endif
:

\onecolumn
\section{Haddock API documentation}

This section just repeats literate documentation in Haddock syntax.

:d Data.Enumerator module header
-----------------------------------------------------------------------------
-- |
-- Module: Data.Enumerator
-- Copyright: 2010 John Millikin
-- License: MIT
--
-- Maintainer: jmillikin@gmail.com
-- Portability: portable
--
-- An implementation of Oleg Kiselyov&#x2019;s left-fold enumerators
--
-----------------------------------------------------------------------------
:

:d apidoc Stream
-- | Not to be confused with types from the @Stream@ or
-- @stream-fusion@ packages, a 'Stream' is a sequence of chunks
-- generated by an 'Enumerator'. In contrast to Oleg&#x2019;s implementation,
-- this stream does not support error handling -- errors encountered
-- while generating a stream are reported in the 'Step' type instead.
--
-- @(Chunks [])@ is used to indicate that a stream is still active, but
-- currently has no available data. Iteratees should ignore empty chunks.
:

:d apidoc Step.Continue
-- | The 'Iteratee' is capable of accepting more input. Note that more input
-- is not necessarily required; the 'Iteratee' might be able to generate a
-- value immediately if it receives 'EOF'.
:

:d apidoc Step.Yield
-- | The 'Iteratee' has received enough input to generate a result.
-- Included in this value is left-over input, which can be passed to
-- composed 'Iteratee's.
:

:d apidoc Step.Error
-- | The 'Iteratee' encountered an error which prevents it from proceeding
-- further.
:

:d apidoc Iteratee
-- | The primary data type for this library, which consumes
-- input from a 'Stream' until it either generates a value or encounters
-- an error. Rather than requiring all input at once, an iteratee will
-- return 'Continue' when it is capable of processing more data.
--
-- In general, iteratees begin in the 'Continue' state. As each chunk is
-- passed to the continuation, the iteratee returns the next step:
-- 'Continue' for more data, 'Yield' when it's finished, or 'Error' to
-- abort processing.
:

:d apidoc Enumerator
-- | While 'Iteratee's consume data, enumerators generate it. Since
-- @'Iteratee'@ is an alias for @m ('Step' a m b)@, 'Enumerator's can
-- be considered step transformers of type
-- @'Step' a m b -> m ('Step' a m b)@.
--
-- 'Enumerator's typically read from an external source (parser, handle,
-- random generator, etc). They feed chunks into an 'Iteratee' until the
-- source runs out of data (triggering 'EOF') or the iteratee finishes
-- processing ('Yield's a value).
:

:d apidoc Enumeratee
-- | In cases where an enumerator acts as both a source and sink, the resulting
-- type is named an 'Enumeratee'. Enumeratees have two input types,
-- &#x201c;outer a&#x201d; (@aOut@) and &#x201c;inner a&#x201d; (@aIn@).
:

:d apidoc liftTrans
-- | Lift an 'Iteratee' onto a monad transformer, re-wrapping the
-- 'Iteratee'&#x2019;s inner monadic values.
:

:d apidoc returnI
:

:d apidoc yield
:

:d apidoc continue
:

:d apidoc throwError
:

:d apidoc liftI
:

:d apidoc (>>==)
-- | Equivalent to (>>=), but allows 'Iteratee's with different input types
-- to be composed.
:

:d apidoc (==<<)
-- | @(==\<\<) = flip (\>\>==)@
:

:d apidoc ($$)
-- | @($$) = (==\<\<)@
--
-- This might be easier to read when passing a chain of iteratees to an
-- enumerator.
:

:d apidoc (>==>)
-- | @(>==>) e1 e2 s = e1 s >>== e2@
:

:d apidoc (<==<)
-- | @(\<==\<) = flip (>==>)@
:

:d apidoc consume
-- | Consume all input until 'EOF', then return consumed input as a list.
:

:d apidoc isEOF
-- | Return 'True' if the next 'Stream' is 'EOF'.
:

:d apidoc foldl
-- | Lifts a pure left fold into an iteratee.
:

:d apidoc foldl'
-- | As 'foldl', but strict in its accumulator.
:

:d apidoc foldM
-- | Lifts a monadic left fold into an iteratee.
:

:d apidoc enumEOF
-- | The most primitive enumerator; simply sends 'EOF'. The iteratee must
-- either yield a value or throw an error continuing receiving 'EOF' will
-- not terminate with any useful value.
:

:d apidoc enumList
-- | Another small, useful enumerator separates an input list into chunks,
-- and sends them to the iteratee. This is useful for testing iteratees in pure
-- code.
:

:d apidoc concatEnums
-- | Compose a list of 'Enumerator's using '(>>==)'
:

:d apidoc joinI
-- | 'joinI' is used to &#x201C;flatten&#x201D; 'Enumeratee's into an
-- 'Iteratee'.
:

:d apidoc checkDoneEx
-- | A common pattern in 'Enumeratee' implementations is to check whether
-- the inner 'Iteratee' has finished, and if so, to return its output.
-- 'checkDone' passes its parameter a continuation if the 'Iteratee'
-- can still consume input, or yields otherwise.
:

:d apidoc checkDone
-- | @checkDone = checkDoneEx (Chunks [])@
--
-- Use this for enumeratees which do not have an input buffer.
:

API docs for these are still TODO

:d apidoc liftMap
:

:d apidoc map
-- | @map f = 'liftMap' ('Prelude.map' f)@
:

:d apidoc concatMap
-- | @concatMap f = 'liftMap' ('Prelude.concatMap' f)@
:

:d apidoc filter
-- | @filter p = 'liftMap' ('Prelude.filter' p)@
:

:d apidoc concatMapM
:

:d apidoc mapM
:

:d apidoc filterM
:

:d apidoc sequence
:

:d apidoc head
:

:d apidoc peek
:

:d apidoc last
:

:d apidoc length
:

:d apidoc drop
:

:d apidoc dropWhile
:

:d apidoc span
:

:d apidoc break
-- | @break p = 'span' (not . p)@
:

:d apidoc parser combinators
-- | Oleg&#x2019;s original @IterateeM.hs@ includes some basic iteratees
-- for parsing, so this section ports them to the new interface. However,
-- in practice most parsing will be performed with enumerator-based
-- interfaces to existing parser libraries (such as Parsec or Attoparsec).
:

:d apidoc run
-- | Run an iteratee until it finishes, and return either the final value
-- (if it succeeded) or the error (if it failed).
:

:d apidoc printChunks
-- | Print chunks as they're received from the enumerator, optionally
-- printing empty chunks.
:

:d Data.Enumerator.IO module header
-----------------------------------------------------------------------------
-- |
-- Module: Data.Enumerator.IO
-- Copyright: 2010 John Millikin
-- License: MIT
--
-- Maintainer: jmillikin@gmail.com
-- Portability: portable
--
-- Enumerator-based IO
--
-----------------------------------------------------------------------------
:

:d apidoc enumHandle
-- | Read bytes (in chunks of the given buffer size) from the handle, and
-- stream them to an 'Iteratee'. If an exception occurs during file IO,
-- enumeration will stop and 'Error' will be returned. Exceptions from the
-- iteratee are not caught.
--
-- This enumerator blocks until at least one byte is available from the
-- handle, and might read less than the maximum buffer size in some
-- cases.
--
-- The handle should be opened with no encoding, and in 'IO.ReadMode' or
-- 'IO.ReadWriteMode'.
:

:d apidoc iterHandle
-- | Read bytes from a stream and write them to a handle. If an exception
-- occurs during file IO, enumeration will stop and 'Error' will be
-- returned.
--
-- The handle should be opened with no encoding, and in 'IO.WriteMode' or
-- 'IO.ReadWriteMode'.
:

:d apidoc enumFile
-- | Opens a file path in binary mode, and passes the handle to 'enumHandle'.
-- The file will be closed when the 'Iteratee' finishes.
:

:d Data.Enumerator.Text module header
-----------------------------------------------------------------------------
-- |
-- Module: Data.Enumerator.Text
-- Copyright: 2010 John Millikin
-- License: MIT
--
-- Maintainer: jmillikin@gmail.com
-- Portability: portable
--
-- Enumerator-based text IO
--
-----------------------------------------------------------------------------
:

:d apidoc enumHandle (text)
-- | Read lines of text from the handle, and stream them to an 'Iteratee'.
-- If an exception occurs during file IO, enumeration will stop and 'Error'
-- will be returned. Exceptions from the iteratee are not caught.
--
-- The handle should be opened with an appropriate text encoding, and
-- in 'IO.ReadMode' or 'IO.ReadWriteMode'.
:

:d apidoc iterHandle (text)
-- | Read text from a stream and write it to a handle. If an exception
-- occurs during file IO, enumeration will stop and 'Error' will be
-- returned.
--
-- The handle should be opened with an appropriate text encoding, and
-- in 'IO.WriteMode' or 'IO.ReadWriteMode'.
:

:d apidoc enumFile (text)
-- | Opens a file path in text mode, and passes the handle to 'enumHandle'.
-- The file will be closed when the 'Iteratee' finishes.
:

:d apidoc Codec
:

:d apidoc encode
:

:d apidoc decode
:

\end{document}
